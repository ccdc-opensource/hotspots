
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hotspots.result &#8212; Hotspots API 1.0.2 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Hotspots API 1.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hotspots.result</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hotspots.result</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The :mod:`hotspots.result` contains classes to extract valuable information from the calculated Fragment Hotspot Maps.</span>

<span class="sd">The main classes of the :mod:`hotspots.result` module are:</span>
<span class="sd">    - :class:`hotspots.result.Results`</span>
<span class="sd">    - :class:`hotspots.result.Extractor`</span>

<span class="sd">:class:`hotspots.result.Results` can be generated using the :mod:`hotspots.calculation` module</span>

<span class="sd">&gt;&gt;&gt; from hotspots.calculation import Runner</span>
<span class="sd">&gt;&gt;&gt;</span>
<span class="sd">&gt;&gt;&gt; r = Runner()</span>

<span class="sd">either</span>

<span class="sd">&gt;&gt;&gt; r.from_pdb(&quot;pdb_code&quot;)</span>

<span class="sd">or</span>

<span class="sd">&gt;&gt;&gt; from ccdc.protein import Protein</span>
<span class="sd">&gt;&gt;&gt; protein = Protein.from_file(&quot;path_to_protein&quot;)</span>
<span class="sd">&gt;&gt;&gt; result = r.from_protein(protein)</span>

<span class="sd">The :class:`hotspots.result.Results` is the central class for the entire API. Every module either feeds into creating</span>
<span class="sd">a :class:`hotspots.result.Results` instance or uses it to generate derived data structures.</span>

<span class="sd">The :class:`hotspots.result.Extractor` enables the main result to be broken down based on molecular volumes. This</span>
<span class="sd">produces molecule sized descriptions of the cavity and aids tractibility analysis and pharmacophoric generation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">getcwd</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">ccdc.cavity</span> <span class="kn">import</span> <span class="n">Cavity</span>
<span class="kn">from</span> <span class="nn">ccdc.molecule</span> <span class="kn">import</span> <span class="n">Molecule</span><span class="p">,</span> <span class="n">Atom</span>
<span class="kn">from</span> <span class="nn">ccdc.pharmacophore</span> <span class="kn">import</span> <span class="n">Pharmacophore</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">percentileofscore</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>

<span class="kn">from</span> <span class="nn">hotspots.grid_extension</span> <span class="kn">import</span> <span class="n">Grid</span><span class="p">,</span> <span class="n">_GridEnsemble</span>

<span class="kn">from</span> <span class="nn">hotspots.hs_pharmacophore</span> <span class="kn">import</span> <span class="n">PharmacophoreModel</span>
<span class="kn">from</span> <span class="nn">hotspots.pharmacophore_extension</span> <span class="kn">import</span> <span class="n">ProteinPharmacophoreModel</span>

<span class="kn">from</span> <span class="nn">hotspots.hs_utilities</span> <span class="kn">import</span> <span class="n">Helper</span>
<span class="kn">from</span> <span class="nn">hotspots.protein_extension</span> <span class="kn">import</span> <span class="n">Protein</span>


<span class="k">class</span> <span class="nc">_Scorer</span><span class="p">(</span><span class="n">Helper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to handle the annotation of objects with Fragment Hotspot Scores</span>

<span class="sd">    :param `hotspots.result.Results` hotspot_result: a Fragment Hotspot Map result</span>
<span class="sd">    :param obj: either `ccdc.molecule.Molecule` or `ccdc.protein.Protein`</span>
<span class="sd">    :param int tolerance: search distance</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hotspot_result</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span> <span class="o">=</span> <span class="n">hotspot_result</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">object</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Protein</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scored_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_protein</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scored_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_molecule</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Cavity</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scored_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_cavity</span><span class="p">()</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">obj</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scored_object</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_hotspot</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;supplied object not currently supported, soz!&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scored_object</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scored_object</span>

    <span class="k">def</span> <span class="nf">_score_protein_cavity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (prefered option)</span>
<span class="sd">        score a protein&#39;s atoms, values stored as partial charge</span>
<span class="sd">        h_bond_distance between 1.5 - 2.5 A (2.0 A taken for simplicity)</span>
<span class="sd">        This method uses the cavity API to reduce the number of atoms to iterate over.</span>

<span class="sd">        :return: :class:`ccdc.protein.Protein`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feats</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">features</span><span class="p">])</span>
        <span class="n">h_bond_distance</span> <span class="o">=</span> <span class="mf">2.0</span>
        <span class="n">interaction_pairs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="s2">&quot;donor&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="s2">&quot;acceptor&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;pi&quot;</span><span class="p">:</span> <span class="s2">&quot;apolar&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;aliphatic&quot;</span><span class="p">:</span> <span class="s2">&quot;apolar&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;aromatic&quot;</span><span class="p">:</span> <span class="s2">&quot;apolar&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;apolar&quot;</span><span class="p">:</span> <span class="s2">&quot;apolar&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;donor_acceptor&quot;</span><span class="p">:</span> <span class="s2">&quot;doneptor&quot;</span><span class="p">,</span>
                             <span class="s2">&quot;dummy&quot;</span><span class="p">:</span> <span class="s2">&quot;dummy&quot;</span><span class="p">}</span>

        <span class="n">cavities</span> <span class="o">=</span> <span class="n">Helper</span><span class="o">.</span><span class="n">cavity_from_protein</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">cavity</span> <span class="ow">in</span> <span class="n">cavities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">cavity</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
                <span class="c1"># all cavity residues</span>
                <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="n">feature</span><span class="o">.</span><span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atm</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">atm</span><span class="o">.</span><span class="n">is_acceptor</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">atm</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s1">&#39;apolar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">get_near_scores</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">score</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
                        <span class="n">prot</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atm</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">score</span>

                <span class="c1"># polar cavity residues</span>
                <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;acceptor&quot;</span> <span class="ow">or</span> <span class="n">feature</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;donor&quot;</span> <span class="ow">or</span> <span class="n">feature</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;doneptor&quot;</span><span class="p">:</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">protein_vector</span>
                    <span class="n">translate</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">h_bond_distance</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">,</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">)))</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">feature</span><span class="o">.</span><span class="n">coordinates</span>
                    <span class="n">coordinates</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">z</span><span class="p">),</span> <span class="n">translate</span><span class="p">))</span>

                    <span class="k">if</span> <span class="n">feature</span><span class="o">.</span><span class="n">atom</span><span class="p">:</span>
                        <span class="n">score</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">score_value</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feats</span> <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">contains_point</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                                 <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">feature_type</span> <span class="o">==</span> <span class="n">interaction_pairs</span><span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">type</span><span class="p">]]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">score</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
                            <span class="nb">print</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

                        <span class="n">prot</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">score</span>

                        <span class="c1"># score hydrogen atoms (important for GOLD)</span>
                        <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">prot</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">atom</span><span class="o">.</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">neighbours</span>
                             <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">atomic_number</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
                                <span class="n">prot</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atm</span><span class="p">]</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">score</span>

        <span class="k">return</span> <span class="n">prot</span>

    <span class="k">def</span> <span class="nf">_score_protein_backup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        backup protein scoring method to deal with cases where the cavity reader fails</span>
<span class="sd">        NB: this scorer is used in the GOLD Docking optimisation work</span>


<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">fetch_scores</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">grid</span><span class="p">]</span><span class="o">.</span><span class="n">get_near_scores</span><span class="p">(</span><span class="n">coordinate</span><span class="o">=</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                                                                                 <span class="n">tolerance</span><span class="o">=</span><span class="n">tolerance</span><span class="p">)</span>
                           <span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">prot</span><span class="o">.</span><span class="n">residues</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">residue</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                <span class="c1"># skip all hydrogens</span>
                <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

                <span class="c1"># score donor hydrogens</span>
                <span class="k">if</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;donor&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">n</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">fetch_scores</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

                <span class="c1"># score donor/acceptors atoms</span>
                <span class="k">elif</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;doneptor&#39;</span><span class="p">:</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">fetch_scores</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">atom</span><span class="o">.</span><span class="n">neighbours</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">n</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">n</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">fetch_scores</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

                <span class="c1"># score remaining atoms</span>
                <span class="k">elif</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">:</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">fetch_scores</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">fetch_scores</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">prot</span>

    <span class="k">def</span> <span class="nf">score_protein</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        score a protein&#39;s atoms, values stored as partial charge</span>

<span class="sd">        :return: :class:`ccdc.protein.Protein`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: enable cavities to be generated from Protein objects</span>

        <span class="n">prot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">object</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">prot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_protein_cavity</span><span class="p">(</span><span class="n">prot</span><span class="o">=</span><span class="n">prot</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">prot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_protein_backup</span><span class="p">(</span><span class="n">prot</span><span class="o">=</span><span class="n">prot</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">prot</span>

    <span class="k">def</span> <span class="nf">score_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        score a molecule&#39;s atoms, values stored as partial charge</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: score has been placed in partial charge field. This score will persist during read and write</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">:</span>
            <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="n">atom</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_atom_type</span><span class="p">(</span><span class="n">atom_type</span><span class="p">,</span> <span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">score</span>

        <span class="k">return</span> <span class="n">mol</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_score_feature</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
        <span class="n">ideal_coord</span> <span class="o">=</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">coordinates</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.8</span> <span class="o">*</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">protein_vector</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">score_cavity</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># TODO: return scored cavity _features, the score protein function should be enough tbh</span>
        <span class="n">cav</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scored_object</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">cav</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_score_feature</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">score_hotspot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hotspot scored on the median value of all points included in the hotspot.</span>
<span class="sd">        NB: grid point with value &lt; 5 are ommited from fragment hotspot map (hence the default threshold)</span>
<span class="sd">        :param percentile:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sg</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">get_single_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sg</span><span class="o">.</span><span class="n">grid_score</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">,</span> <span class="n">percentile</span><span class="o">=</span><span class="n">percentile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_score_atom_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_type</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        atom</span>
<span class="sd">        :param grid_type:</span>
<span class="sd">        :param coordinate:</span>
<span class="sd">        :param tolerance:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">grid_type</span> <span class="o">==</span> <span class="s2">&quot;doneptor&quot;</span><span class="p">:</span>
            <span class="n">grid_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doneptor_grid</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">grid_type</span><span class="p">]</span><span class="o">.</span><span class="n">value_at_coordinate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span>
                                                                              <span class="n">tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                                                                              <span class="n">position</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_percentage_rank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NB: must score obj first!</span>
<span class="sd">        :param obj:</span>
<span class="sd">        :param threshold:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">scored_object</span><span class="p">)</span>
        <span class="n">adict</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">grid_values</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom_type</span> <span class="o">==</span> <span class="s2">&quot;doneptor&quot;</span><span class="p">:</span>
                <span class="n">atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_doneptor_grid</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">atom</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">percentileofscore</span><span class="p">(</span><span class="n">adict</span><span class="p">[</span><span class="n">atom_type</span><span class="p">],</span> <span class="n">atom</span><span class="o">.</span><span class="n">partial_charge</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">_doneptor_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        An atom is scored from the grid which yields the highest value</span>
<span class="sd">        :param coordinates:</span>
<span class="sd">        :param grid_type:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;donor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_at_coordinate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span>
                                                                               <span class="n">tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                                                                               <span class="n">position</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
                  <span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_at_coordinate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span>
                                                                                  <span class="n">tolerance</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span><span class="p">,</span>
                                                                                  <span class="n">position</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                  <span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="s2">&quot;acceptor&quot;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">())]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_atom_type</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        from a ccdc Atom, the &quot;atom type&quot; is returned</span>
<span class="sd">        :param a:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">and</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;doneptor&quot;</span>

        <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;acceptor&quot;</span>

        <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">is_donor</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;donor&quot;</span>

        <span class="k">elif</span> <span class="n">atom</span><span class="o">.</span><span class="n">atomic_symbol</span> <span class="o">==</span> <span class="s2">&quot;Xe&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;dummy&quot;</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;apolar&quot;</span>


<div class="viewcode-block" id="Results"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results">[docs]</a><span class="k">class</span> <span class="nc">Results</span><span class="p">(</span><span class="n">Helper</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to handle the results of the Fragment Hotspot Map calcation and to organise subsequent analysis</span>

<span class="sd">    :param dict super_grids: key = probe identifier and value = grid</span>
<span class="sd">    :param `ccdc.protein.Protein` protein: target protein</span>
<span class="sd">    :param `ccdc.utilities.Grid` buriedness: the buriedness grid</span>
<span class="sd">    :param bool pharmacophore: if True, a pharmacophore will be generated</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">super_grids</span><span class="p">,</span> <span class="n">protein</span><span class="p">,</span> <span class="n">buriedness</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pharmacophore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">superstar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">weighted_superstar</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="n">super_grids</span>
        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">assert</span> <span class="nb">type</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">,</span> <span class="s2">&quot;Not a valid Grid&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">protein</span> <span class="o">=</span> <span class="n">protein</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">buriedness</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superstar</span> <span class="o">=</span> <span class="n">superstar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_superstar</span> <span class="o">=</span> <span class="n">weighted_superstar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pharmacophore</span> <span class="o">=</span> <span class="n">pharmacophore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_features</span><span class="p">(</span><span class="n">interaction_dict</span><span class="o">=</span><span class="n">super_grids</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">pharmacophore</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pharmacophore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pharmacophore_model</span><span class="p">()</span>

    <span class="k">class</span> <span class="nc">_ConstraintData</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        standardise constrain read and write (required for the GOLD optimisation)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score_by_index</span><span class="p">,</span> <span class="n">prot</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">score_by_index</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="n">score_by_index</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">protein</span> <span class="o">=</span> <span class="n">prot</span>

        <span class="k">def</span> <span class="nf">to_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protein</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">protein</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">protein</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;Give me a protein&quot;</span><span class="p">)</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;constraints&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">score</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_by_index</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">atm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                <span class="n">atm</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
                <span class="n">mol</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">atm</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mol</span>

        <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">score_by_index</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">Results</span><span class="o">.</span><span class="n">_ConstraintData</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">class</span> <span class="nc">_HotspotFeature</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        class to hold polar islands above threshold &quot;_features&quot;</span>
<span class="sd">        purpose: enables feature ranking</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">feature_type</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">            :param feature_type:</span>
<span class="sd">            :param grid:</span>
<span class="sd">            :param threshold:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_feature_type</span> <span class="o">=</span> <span class="n">feature_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">grid</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_feature_coordinates</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_threshold</span> <span class="o">=</span> <span class="n">threshold</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_score_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_feature</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sphere</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># set these</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">superstar_results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">feature_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_type</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_grid</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">feature_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_feature_coordinates</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sphere</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">score_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_score_value</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rank</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">threshold</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_threshold</span>

        <span class="c1"># def score_feature(self, threshold=14, percentile=99):</span>
        <span class="c1">#     &quot;&quot;&quot;</span>
        <span class="c1">#     returns</span>
        <span class="c1">#     :return:</span>
        <span class="c1">#     &quot;&quot;&quot;</span>
        <span class="c1">#     return self.grid.grid_score(threshold=threshold,</span>
        <span class="c1">#                                 percentile=percentile)</span>
        <span class="k">def</span> <span class="nf">score_feature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            returns</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">extrema</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_features</span>

    <span class="nd">@features</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_features</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_features</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

    <span class="c1"># def tractability_map(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     generate the best volume and labels with the median value. A median &gt; 14 is more likely to be tractable</span>
    <span class="c1">#</span>
    <span class="c1">#     :return: a :class:`hotspots.result.Results` instance</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     extractor_settings = Extractor.Settings()</span>
    <span class="c1">#     extractor_settings.cutoff = 5</span>
    <span class="c1">#     extractor_settings.island_max_size = 500</span>
    <span class="c1">#</span>
    <span class="c1">#     extractor = Extractor(self, settings=extractor_settings)</span>
    <span class="c1">#     extractor.extract_best_volume(volume=500)</span>
    <span class="c1">#     # hist = extractor.extracted_hotspots[0].map_values()</span>
    <span class="c1">#     #</span>
    <span class="c1">#     # all_points = []</span>
    <span class="c1">#     # for x in hist.values():</span>
    <span class="c1">#     #     all_points += x.flatten().tolist()</span>
    <span class="c1">#     #</span>
    <span class="c1">#     # all_points = all_points[all_points != 0]</span>
    <span class="c1">#     # print(all_points)</span>
    <span class="c1">#     best_vol = extractor.extracted_hotspots[0]</span>
    <span class="c1">#     best_vol.identifier = best_vol.score()</span>
    <span class="c1">#</span>
    <span class="c1">#     return best_vol</span>
    <span class="c1">#</span>
    <span class="c1"># def all_tractability_maps(self):</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     generate the best volume and labels with the median value. A median &gt; 14 is more likely to be tractable</span>
    <span class="c1">#</span>
    <span class="c1">#     :return: a :class:`hotspots.result.Results` instance</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     extractor_settings = Extractor.Settings()</span>
    <span class="c1">#     extractor_settings.cutoff = 5</span>
    <span class="c1">#     extractor_settings.island_max_size = 500</span>
    <span class="c1">#</span>
    <span class="c1">#     extractor = Extractor(self, settings=extractor_settings)</span>
    <span class="c1">#     extractor.extract_all_volumes(volume=500)</span>
    <span class="c1">#     extracted = []</span>
    <span class="c1">#     for cav in extractor.extracted_hotspots:</span>
    <span class="c1">#         hist = cav.map_values()</span>
    <span class="c1">#         all_points = []</span>
    <span class="c1">#         for x in hist.values():</span>
    <span class="c1">#             all_points += x.flatten().tolist()</span>
    <span class="c1">#</span>
    <span class="c1">#         all_points = all_points[all_points != 0]</span>
    <span class="c1">#         best_vol = cav</span>
    <span class="c1">#         best_vol.identifier = np.median(all_points)</span>
    <span class="c1">#         extracted.append(best_vol)</span>
    <span class="c1">#</span>
    <span class="c1">#     return extracted</span>

<div class="viewcode-block" id="Results.score"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.score">[docs]</a>    <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        annotate protein, molecule or self with Fragment Hotspot scores</span>

<span class="sd">        :param obj: `ccdc.protein.Protein`, `ccdc.molecule.Molecule` or `hotsptos.result.Results` (find the median)</span>
<span class="sd">        :param int tolerance: the search radius around each point</span>
<span class="sd">        :return: scored obj, either :class:`ccdc.protein.Protein`, :class:`ccdc.molecule.Molecule` or :class:`hotspot.result.Results`</span>

<span class="sd">        &gt;&gt;&gt; result          # example &quot;1hcl&quot;</span>
<span class="sd">        &lt;hotspots.result.Results object at 0x000000001B657940&gt;</span>

<span class="sd">        &gt;&gt;&gt; from numpy import np</span>
<span class="sd">        &gt;&gt;&gt; p = result.score(result.protein)    # scored protein</span>
<span class="sd">        &gt;&gt;&gt; np.median([a.partial_charge for a in p.atoms if a.partial_charge &gt; 0])</span>
<span class="sd">        8.852499961853027</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_Scorer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span><span class="o">.</span><span class="n">scored_object</span></div>

    <span class="k">def</span> <span class="nf">_filter_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">,</span> <span class="n">tol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Experimental feature*</span>

<span class="sd">        Takes 2 grids of the same size and coordinate frames. Points that are</span>
<span class="sd">        zero in one grid but sampled in the other are</span>
<span class="sd">        set to the mean of their nonzero neighbours. Grids are then subtracted and</span>
<span class="sd">        the result is returned.</span>

<span class="sd">        :param int tol: how many grid points away to consider scores from</span>
<span class="sd">        :param g1: a :class: &quot;ccdc.utilities.Grid&quot; instance</span>
<span class="sd">        :param g2: a :class: &quot;ccdc.utilities.Grid&quot; instance</span>
<span class="sd">        :return: a :class: &quot;ccdc.utilities.Grid&quot; instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">filter_point</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
            <span class="n">loc_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">g</span><span class="p">[</span><span class="n">x</span> <span class="o">+</span> <span class="n">i</span><span class="p">][</span><span class="n">y</span> <span class="o">+</span> <span class="n">j</span><span class="p">][</span><span class="n">z</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">tol</span><span class="p">,</span> <span class="n">tol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">tol</span><span class="p">,</span> <span class="n">tol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span>
                 <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">tol</span><span class="p">,</span> <span class="n">tol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
            <span class="k">if</span> <span class="n">loc_arr</span><span class="p">[</span><span class="n">loc_arr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># print(np.mean(loc_arr[loc_arr &gt; 0]))</span>
                <span class="n">new_grid</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="n">y</span><span class="p">][</span><span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">loc_arr</span><span class="p">[</span><span class="n">loc_arr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">vfilter_point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">filter_point</span><span class="p">)</span>
        <span class="n">com_bound_box</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">com_spacing</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">spacing</span>

        <span class="n">arr1</span> <span class="o">=</span> <span class="n">g1</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">arr2</span> <span class="o">=</span> <span class="n">g2</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>

        <span class="n">b_arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span>
        <span class="n">b_arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span>

        <span class="n">b_arr1</span><span class="p">[</span><span class="n">b_arr1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">b_arr2</span><span class="p">[</span><span class="n">b_arr2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>

        <span class="n">diff_arr</span> <span class="o">=</span> <span class="n">b_arr1</span> <span class="o">+</span> <span class="n">b_arr2</span>

        <span class="n">unmatch1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_arr</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">unmatch2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">diff_arr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">arr1</span>
        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">arr1</span><span class="p">)</span>
        <span class="n">vfilter_point</span><span class="p">(</span><span class="n">unmatch2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unmatch2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unmatch2</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">f_arr1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new_grid</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">arr2</span>
        <span class="n">new_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">arr2</span><span class="p">)</span>
        <span class="n">vfilter_point</span><span class="p">(</span><span class="n">unmatch1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unmatch1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unmatch1</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">f_arr2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new_grid</span><span class="p">)</span>

        <span class="n">sel_arr</span> <span class="o">=</span> <span class="n">f_arr1</span> <span class="o">-</span> <span class="n">f_arr2</span>
        <span class="n">sel_arr</span><span class="p">[</span><span class="n">sel_arr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sel_map</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">origin</span><span class="o">=</span><span class="n">com_bound_box</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">far_corner</span><span class="o">=</span><span class="n">com_bound_box</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">spacing</span><span class="o">=</span><span class="n">com_spacing</span><span class="p">,</span> <span class="n">_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="n">sel_arr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">sel_arr</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>

        <span class="n">as_triads</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">idxs</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">as_triads</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
            <span class="n">sel_map</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sel_map</span>

<div class="viewcode-block" id="Results.get_difference_map"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.get_difference_map">[docs]</a>    <span class="k">def</span> <span class="nf">get_difference_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Experimental feature.*</span>
<span class="sd">        Generates maps to highlight selectivity for a target over an off target cavity. Proteins should be aligned</span>
<span class="sd">        by the binding site of interest prior to calculation.</span>
<span class="sd">        High scoring regions of a map represent areas of favourable interaction in the target binding site, not</span>
<span class="sd">        present in off target binding site</span>

<span class="sd">        :param other: a :class:`hotspots.result.Results` instance</span>
<span class="sd">        :param int tolerance: how many grid points away to apply filter to</span>
<span class="sd">        :return: a :class:`hotspots.result.Results` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">selectivity_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">g1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span>
            <span class="n">g2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span>
            <span class="n">og1</span><span class="p">,</span> <span class="n">og2</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">common_grid</span><span class="p">([</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span><span class="p">])</span>
            <span class="n">sele</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_filter_map</span><span class="p">(</span><span class="n">og1</span><span class="p">,</span> <span class="n">og2</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">)</span>
            <span class="n">selectivity_grids</span><span class="p">[</span><span class="n">probe</span><span class="p">]</span> <span class="o">=</span> <span class="n">sele</span>
        <span class="n">hr</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">selectivity_grids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hr</span></div>

<div class="viewcode-block" id="Results.from_grid_ensembles"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.from_grid_ensembles">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_grid_ensembles</span><span class="p">(</span><span class="n">res_list</span><span class="p">,</span> <span class="n">prot_name</span><span class="p">,</span> <span class="n">charged</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Experimental feature*</span>

<span class="sd">        Creates ensemble map from a list of Results. Structures in the ensemble have to aligned by the</span>
<span class="sd">        binding site of interest prior to the hotspots calculation.</span>

<span class="sd">        TODO: Move to the calculation module?</span>

<span class="sd">        :param res_list: list of `hotspots.result.Results`</span>
<span class="sd">        :param str prot_name: str</span>
<span class="sd">        :param str out_dir: path to output directory</span>
<span class="sd">        :return: a :class:`hotspots.result.Results` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">charged</span><span class="p">:</span>
            <span class="n">probe_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="s2">&quot;apolar&quot;</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">,</span> <span class="s2">&quot;positive&quot;</span><span class="p">,</span> <span class="s2">&quot;negative&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">probe_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">,</span> <span class="s2">&quot;apolar&quot;</span><span class="p">,</span> <span class="s2">&quot;donor&quot;</span><span class="p">]</span>

        <span class="n">grid_dic</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">probe_list</span><span class="p">:</span>
            <span class="n">grid_list_p</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res_list</span><span class="p">]</span>
            <span class="n">ens</span> <span class="o">=</span> <span class="n">_GridEnsemble</span><span class="p">()</span>
            <span class="n">grid_dic</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">ens</span><span class="o">.</span><span class="n">from_grid_list</span><span class="p">(</span><span class="n">grid_list_p</span><span class="p">,</span> <span class="n">getcwd</span><span class="p">(),</span> <span class="n">prot_name</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="n">hr</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">grid_dic</span><span class="p">,</span> <span class="n">protein</span><span class="o">=</span><span class="n">res_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hr</span></div>

<div class="viewcode-block" id="Results.get_pharmacophore_model"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.get_pharmacophore_model">[docs]</a>    <span class="k">def</span> <span class="nf">get_pharmacophore_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;id_01&quot;</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a :class:`hotspots.hotspot_pharmacophore.PharmacophoreModel` instance from peaks in the hotspot maps</span>

<span class="sd">        TODO: investigate using feature recognition to go from grids to features.</span>

<span class="sd">        :param str identifier: Identifier for displaying multiple models at once</span>
<span class="sd">        :param float cutoff: The score cutoff used to identify islands in the maps. One peak will be identified per island</span>
<span class="sd">        :return: a :class:`hotspots.hotspot_pharmacophore.PharmacophoreModel` instance</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">PharmacophoreModel</span><span class="o">.</span><span class="n">from_hotspot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="o">=</span><span class="n">identifier</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span></div>

<div class="viewcode-block" id="Results.grid_labels"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.grid_labels">[docs]</a>    <span class="k">def</span> <span class="nf">grid_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect local maxima and generate a dict of peak by value</span>

<span class="sd">        :return: Peak coordinates by peak values.</span>
<span class="sd">        :rtype: dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">max_value_of_neighbours</span><span class="p">()</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">gaussian</span><span class="p">()</span>
            <span class="c1"># take the original grid value, grid modifications for peak</span>
            <span class="c1"># detection purposes only, not to augment the HS values</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">p</span><span class="p">:</span> <span class="p">{</span><span class="n">peak</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">value_at_point</span><span class="p">(</span><span class="n">peak</span><span class="p">)</span> <span class="k">for</span> <span class="n">peak</span> <span class="ow">in</span> <span class="n">h</span><span class="o">.</span><span class="n">get_peaks</span><span class="p">(</span><span class="n">min_distance</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">5</span><span class="p">)}})</span>

        <span class="k">return</span> <span class="n">labels</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_island_to_atom</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="c1"># island</span>
        <span class="n">island_pnts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">island</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>

        <span class="c1"># projected spheres</span>
        <span class="n">projs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">f</span><span class="o">.</span><span class="n">projected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centre</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                           <span class="n">f</span><span class="o">.</span><span class="n">projected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centre</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                           <span class="n">f</span><span class="o">.</span><span class="n">projected</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">centre</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features</span><span class="p">])</span>

        <span class="c1"># distance matrix</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">island_pnts</span><span class="p">,</span> <span class="n">projs</span><span class="p">)</span>

        <span class="c1"># create mask</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">tolerance</span><span class="p">)</span>

        <span class="c1"># return features above threshold</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">features</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_map_features_to_protein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">min_grid_pts</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="c1"># do it cavity by cavity</span>
        <span class="c1"># interaction dict {probe name: pharmacophore name}</span>
        <span class="n">interaction_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;acceptor_projected&quot;</span><span class="p">],</span>
                            <span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;donor_projected&quot;</span><span class="p">,</span> <span class="s2">&quot;donor_ch_projected&quot;</span><span class="p">],</span>
                            <span class="p">}</span>

        <span class="n">new_super_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">smooth</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">max_value_of_neighbours</span><span class="p">()</span>
                <span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="o">.</span><span class="n">gaussian</span><span class="p">()</span>
                <span class="n">new_super_grids</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">p</span><span class="p">:</span> <span class="n">h</span><span class="p">})</span>

        <span class="n">cavities</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">b_threshold</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">grid_values</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">b_threshold</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">min_grid_pts</span><span class="p">]</span>

        <span class="n">pairs_by_cavity</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cavity</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">cavities</span><span class="p">[</span><span class="mi">0</span><span class="p">]]):</span>
            <span class="n">cavity</span> <span class="o">=</span> <span class="p">(</span><span class="n">cavity</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="n">cavity</span>
            <span class="n">bs</span> <span class="o">=</span> <span class="n">Protein</span><span class="o">.</span><span class="n">BindingSiteFromGrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">,</span> <span class="n">cavity</span><span class="p">,</span> <span class="n">within</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
            <span class="n">binding_site</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="p">({</span><span class="n">r</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">binding_site</span><span class="o">.</span><span class="n">residues</span><span class="p">}</span> <span class="o">-</span> <span class="p">{</span><span class="n">r</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">bs</span><span class="o">.</span><span class="n">residues</span><span class="p">}):</span>
                <span class="n">binding_site</span><span class="o">.</span><span class="n">remove_residue</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

            <span class="c1"># cavity features</span>
            <span class="n">pm</span> <span class="o">=</span> <span class="n">ProteinPharmacophoreModel</span><span class="p">()</span>
            <span class="n">pm</span><span class="o">.</span><span class="n">feature_definitions</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;acceptor_projected&quot;</span><span class="p">,</span> <span class="s2">&quot;donor_projected&quot;</span><span class="p">,</span> <span class="s2">&quot;donor_ch_projected&quot;</span><span class="p">]</span>
            <span class="n">pm</span><span class="o">.</span><span class="n">detect_from_prot</span><span class="p">(</span><span class="n">binding_site</span><span class="p">)</span>
            <span class="n">cavity_features</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">pm</span><span class="o">.</span><span class="n">selected_features</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">cavity_features</span><span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">identifier</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feature</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">cavity_features</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">feature</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="p">[</span><span class="n">feature</span><span class="p">]})</span>

            <span class="n">island_partners</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">new_super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="s2">&quot;apolar&quot;</span><span class="p">:</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">&amp;</span> <span class="n">g</span><span class="o">.</span><span class="n">common_boundaries</span><span class="p">(</span><span class="n">cavity</span><span class="p">))</span> <span class="o">*</span> <span class="n">g</span>

                    <span class="n">island_partners</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_island_to_atom</span><span class="p">(</span><span class="n">cavity_features</span><span class="p">[</span><span class="n">partner</span><span class="p">],</span> <span class="n">island</span><span class="p">)</span>
                                            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">island</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">h</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">))</span>
                                            <span class="k">for</span> <span class="n">partner</span> <span class="ow">in</span> <span class="n">interaction_dict</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
                                            <span class="p">})</span>

                    <span class="n">pairs_by_cavity</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;cavity_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">island_partners</span><span class="p">})</span>
            <span class="n">pm</span><span class="o">.</span><span class="n">selected_features</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pairs_by_cavity</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;cavity_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">]</span>
            <span class="n">new_super_grids</span><span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;/home/pcurran/github_packages/hotspots/tests/testdata/result/map_features/acceptor.grd&quot;</span><span class="p">)</span>
            <span class="n">new_super_grids</span><span class="p">[</span><span class="s2">&quot;donor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="s2">&quot;/home/pcurran/github_packages/hotspots/tests/testdata/result/map_features/donor.grd&quot;</span><span class="p">)</span>
            <span class="n">pm</span><span class="o">.</span><span class="n">pymol_visulisation</span><span class="p">(</span><span class="s2">&quot;/home/pcurran/github_packages/hotspots/tests/testdata/result/map_features&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">pairs_by_cavity</span>

<div class="viewcode-block" id="Results.atomic_volume_overlap"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.atomic_volume_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">atomic_volume_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for a given mol, return a dictionary of dictionaries containing the percentage overlap of each atoms</span>
<span class="sd">        VDW radius with the Hotspot Grids.</span>

<span class="sd">        {&quot;donor&quot;: {&quot;atomic_label&quot;: percentage_overlap}</span>

<span class="sd">        :param mol:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">atom_type_dic</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># if an atom is a donor and acceptor consider overlap twice</span>
            <span class="n">atms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atom_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
                    <span class="ow">or</span> <span class="p">((</span><span class="n">n</span> <span class="o">==</span> <span class="s1">&#39;donor&#39;</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atom_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;doneptor&#39;</span><span class="p">)]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">overlap_dic</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">atomic_overlap</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">return_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atms</span><span class="p">}</span>
                <span class="n">atom_type_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">overlap_dic</span><span class="p">})</span>
        <span class="nb">print</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">atom_type_dic</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">atom_type_dic</span></div>

<div class="viewcode-block" id="Results.percentage_matched_atoms"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.percentage_matched_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">percentage_matched_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">match_atom_types</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        for a given molecule, the &#39;percentage match&#39; is given by the percentage of atoms</span>
<span class="sd">        which overlap with the hotspot result (over a given overlap threshol)</span>

<span class="sd">        :param mol:</span>
<span class="sd">        :param threshold:</span>
<span class="sd">        :param match_atom_types:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matched_atom_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">match_atom_types</span><span class="p">:</span>
            <span class="n">atom_type_dic</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># if an atom is a donor and acceptor consider overlap twice</span>
                <span class="n">atms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atom_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span>
                        <span class="ow">or</span> <span class="p">((</span><span class="n">n</span> <span class="o">==</span> <span class="s1">&#39;donor&#39;</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="s1">&#39;acceptor&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_atom_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;doneptor&#39;</span><span class="p">)]</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="n">matched</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">matched_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">atms</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
                    <span class="n">matched_atom_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched</span><span class="p">)</span>
                    <span class="n">atom_type_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">n</span><span class="p">:</span> <span class="n">matched</span><span class="p">})</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;heavy atoms matched: </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matched_atom_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">)))</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;breakdown by atom type&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">atom_type_dic</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">round</span><span class="p">((</span><span class="n">matched_atom_count</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">atom_type_dic</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sg</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">get_single_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="n">sg</span><span class="o">.</span><span class="n">matched_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>
            <span class="n">matched_atom_count</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matched</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;heavy atoms matched: </span><span class="si">{}</span><span class="s2">/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">matched_atom_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">)))</span>
            <span class="k">return</span> <span class="nb">round</span><span class="p">((</span><span class="n">matched_atom_count</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">))</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_is_solvent_accessible</span><span class="p">(</span><span class="n">protein_coords</span><span class="p">,</span> <span class="n">atm</span><span class="p">,</span> <span class="n">min_distance</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        given a protein and an atom of a protein, determine if the atom is accessible to solvent</span>
<span class="sd">        :param protein:</span>
<span class="sd">        :param atm:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">atomic_symbol</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
            <span class="n">atm_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">neighbour</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">atm</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">direction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">atm_position</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">direction</span> <span class="o">+</span> <span class="n">atm_position</span><span class="p">])</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">protein_coords</span> <span class="o">-</span> <span class="n">position</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">distance</span> <span class="o">&gt;</span> <span class="n">min_distance</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_docking_fitting_pts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_best_island</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">17</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">_best_island</span><span class="p">:</span>
            <span class="n">single_grid</span> <span class="o">=</span> <span class="n">_best_island</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">single_grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">get_single_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="n">single_grid</span><span class="o">.</span><span class="n">grid_value_by_coordinates</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">)</span>

        <span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;constraints&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">score</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dic</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">pts</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
                <span class="n">atm</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">atomic_symbol</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span>
                           <span class="n">atomic_number</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
                           <span class="n">label</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">score</span><span class="p">),</span>
                           <span class="n">coordinates</span><span class="o">=</span><span class="n">pts</span><span class="p">)</span>
                <span class="n">atm</span><span class="o">.</span><span class="n">partial_charge</span> <span class="o">=</span> <span class="n">score</span>
                <span class="n">mol</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">atom</span><span class="o">=</span><span class="n">atm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mol</span>

    <span class="k">def</span> <span class="nf">_output_feature_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;apolar&quot;</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">,</span>
               <span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="s2">&quot;N&quot;</span><span class="p">,</span>
               <span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="s2">&quot;O&quot;</span><span class="p">}</span>
        <span class="n">mol</span> <span class="o">=</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="s2">&quot;centroids&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feat</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">feat</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
            <span class="n">mol</span><span class="o">.</span><span class="n">add_atom</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">atomic_symbol</span><span class="o">=</span><span class="n">dic</span><span class="p">[</span><span class="n">feat</span><span class="o">.</span><span class="n">feature_type</span><span class="p">],</span>
                              <span class="n">atomic_number</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span>
                              <span class="n">coordinates</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span>
                              <span class="n">label</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)))</span>
        <span class="kn">from</span> <span class="nn">ccdc</span> <span class="kn">import</span> <span class="n">io</span>
        <span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">MoleculeWriter</span><span class="p">(</span><span class="s2">&quot;cenroid.mol2&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="n">w</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">mol</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_docking_constraint_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_constraints</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">accessible_cutoff</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">max_distance</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">min_size</span> <span class="o">=</span> <span class="mi">15</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        creates a dictionary of constraints</span>

<span class="sd">        :param int max_constraints: max number of constraints</span>
<span class="sd">        :return dic: score by atom</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>

        <span class="k">def</span> <span class="nf">check_hydrogens</span><span class="p">(</span><span class="n">protein</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;check hydrogens have neighbours&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">neighbours</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">protein</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING HYDROGENS READDED THIS MAY CAUSE ISSUES&quot;</span><span class="p">)</span>
                <span class="n">protein</span><span class="o">.</span><span class="n">add_hydrogens</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_hydrogens</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
            <span class="n">protein</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">check_hydrogens</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="n">protein</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s1">&#39;apolar&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">centroid</span><span class="p">()</span>
        <span class="n">bs</span> <span class="o">=</span> <span class="n">protein</span><span class="o">.</span><span class="n">BindingSiteFromPoint</span><span class="p">(</span><span class="n">protein</span><span class="o">=</span><span class="n">protein</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">point</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="mf">12.</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">protein</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="n">remove</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">protein</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">bs</span><span class="o">.</span><span class="n">residues</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">remove</span><span class="p">:</span>
            <span class="n">protein</span><span class="o">.</span><span class="n">remove_residue</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">atoms</span><span class="p">))</span>

        <span class="n">donors</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">protein</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">atomic_number</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
                  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">neighbours</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_donor</span> 
                  <span class="c1"># and x.solvent_accessible_surface() &gt; accessible_cutoff</span>
                  <span class="p">}</span>

        <span class="n">acceptors</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">protein</span><span class="o">.</span><span class="n">atoms</span>
                     <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span>
                     <span class="c1"># and a.solvent_accessible_surface() &gt; accessible_cutoff</span>
                     <span class="p">}</span>

        <span class="n">pairs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="n">donors</span><span class="p">,</span>
                 <span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="n">acceptors</span><span class="p">}</span>

        <span class="n">constraint_dic</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">feature</span><span class="o">.</span><span class="n">grid</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">min_size</span><span class="p">:</span>
                <span class="n">centoid</span> <span class="o">=</span> <span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">centroid</span><span class="p">()]</span>
                <span class="n">coords</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">feature_type</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="n">all_distances</span> <span class="o">=</span> <span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">centoid</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">all_distances</span><span class="p">))</span>
                <span class="n">min_coord</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                <span class="n">atm_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pairs</span><span class="p">[</span><span class="n">feature</span><span class="o">.</span><span class="n">feature_type</span><span class="p">][</span><span class="n">min_coord</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">all_distances</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">max_distance</span><span class="p">:</span>
                    <span class="n">constraint_dic</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">feature</span><span class="o">.</span><span class="n">score_value</span><span class="p">:</span> <span class="n">atm_index</span><span class="p">})</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">constraint_dic</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_constraints</span><span class="p">:</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">constraint_dic</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)[:</span><span class="n">max_constraints</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">constraint_dic</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">bin_keys</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">constraint_dic</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">bin_keys</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">constraint_dic</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="n">constraint_dic</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">constraint_dic</span><span class="o">.</span><span class="n">items</span><span class="p">())))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ConstraintData</span><span class="p">(</span><span class="n">constraint_dic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_usr_moment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">14</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        PRIVATE</span>
<span class="sd">        This is some experimental code and requires seperate installation of USR</span>
<span class="sd">        generates USR moments for shape analysis</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">hs_utilities</span> <span class="kn">import</span> <span class="n">_generate_usr_moment</span>

            <span class="n">coords_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">coordinates</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">))</span>
                           <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                           <span class="k">if</span> <span class="n">p</span> <span class="o">!=</span> <span class="s2">&quot;negative&quot;</span> <span class="ow">and</span> <span class="n">p</span> <span class="o">!=</span> <span class="s2">&quot;positive&quot;</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">_generate_usr_moment</span><span class="p">(</span><span class="n">fcoords_list</span><span class="o">=</span><span class="n">coords_list</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To use this feature you must have USR installed&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Results.map_values"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Results.map_values">[docs]</a>    <span class="k">def</span> <span class="nf">map_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the number zero grid points for the Fragment Hotspot Result</span>

<span class="sd">        :return: dict of str(probe type) by a :class:`numpy.array` (non-zero grid point scores)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_features</span><span class="p">(</span><span class="n">interaction_dict</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">min_feature_gp</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;apolar&quot;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns Hotspot Feature object with a score to enable ranking</span>
<span class="sd">        :param probe:</span>
<span class="sd">        :param g:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">interaction_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">island</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="n">threshold</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">island</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">)</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">min_feature_gp</span> <span class="ow">and</span> <span class="n">probe</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded</span><span class="p">:</span>

                        <span class="n">f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Results</span><span class="o">.</span><span class="n">_HotspotFeature</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="n">island</span><span class="p">,</span> <span class="n">threshold</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">_rank_features</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        rank _features based upon feature score (TO DO: modify score if required)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">feature_by_score</span> <span class="o">=</span> <span class="p">{</span><span class="n">feat</span><span class="o">.</span><span class="n">score_value</span><span class="p">:</span> <span class="n">feat</span> <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">features</span><span class="p">}</span>
        <span class="n">score</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">feature_by_score</span><span class="o">.</span><span class="n">items</span><span class="p">()],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">score</span><span class="p">):</span>
            <span class="n">feature_by_score</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">_rank</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Extractor"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Extractor">[docs]</a><span class="k">class</span> <span class="nc">Extractor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to handle the extraction of molecular volumes from a Fragment Hotspot Map result</span>

<span class="sd">    :param `hotspots.HotspotResults` hr: A Fragment Hotspot Maps result</span>
<span class="sd">    :param `hotspots.Extractor.Settings` settings: Extractor settings</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Extractor.Settings"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Extractor.Settings">[docs]</a>    <span class="k">class</span> <span class="nc">Settings</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Default settings for hotspot extraction</span>

<span class="sd">        :param float volume: required volume (default = 150)</span>
<span class="sd">        :param float cutoff: only features above this value are considered (default = 14)</span>
<span class="sd">        :param float spacing: grid spacing, (default = 0.5)</span>
<span class="sd">        :param bool mvon: Run Max value of neighbours (default = True)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="mi">14</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mvon</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cutoff</span> <span class="o">=</span> <span class="n">cutoff</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">=</span> <span class="n">spacing</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mvon</span> <span class="o">=</span> <span class="n">mvon</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">_num_gp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            number of grid point for a given volume</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">volume</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">spacing</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hr</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_single_grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_masked_dic</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_dir</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extracted_hotspots</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">mvon</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">probe</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">max_value_of_neighbours</span><span class="p">()</span> <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
            <span class="c1">#hr.super_grids.update({probe: g.dilate_by_atom() for probe, g in hr.super_grids.items()})</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;negative&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;negative&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">deduplicate</span><span class="p">(</span><span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;acceptor&quot;</span><span class="p">],</span>
                                                                                <span class="n">threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                                                <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;positive&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;positive&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">deduplicate</span><span class="p">(</span><span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="p">[</span><span class="s2">&quot;donor&quot;</span><span class="p">],</span>
                                                                                <span class="n">threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
                                                                                <span class="n">tolerance</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">probe</span><span class="p">:</span> <span class="n">g</span><span class="o">.</span><span class="n">minimal</span><span class="p">()</span> <span class="k">for</span> <span class="n">probe</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">hr</span><span class="o">.</span><span class="n">super_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span> <span class="o">=</span> <span class="n">hr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_masked_dic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">get_single_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">super_grids</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">single_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_grid</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">masked_dic</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_masked_dic</span>

    <span class="k">def</span> <span class="nf">_grow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A single grid is iteratively inflated, and the top 20% of neighbouring grid points added until the volume</span>
<span class="sd">        is with the tolerance of the target volume.</span>

<span class="sd">        :param float tolerance: allowable error in volume extraction</span>
<span class="sd">        :return float: threshold</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_grid</span><span class="o">.</span><span class="n">common_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_island</span><span class="p">)</span>
        <span class="n">current_num_gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span>

        <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="mi">100</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">_num_gp</span> <span class="o">-</span> <span class="n">current_num_gp</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">_num_gp</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">tolerance</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">_num_gp</span> <span class="o">&gt;=</span> <span class="n">current_num_gp</span><span class="p">:</span>
            <span class="n">grown</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">grow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">best_island</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_grid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span> <span class="o">=</span> <span class="n">grown</span>
            <span class="n">current_num_gp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">current_num_gp</span><span class="p">,</span> <span class="s1">&#39;out of&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">_num_gp</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">tmp_best_island</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_grid</span>
        <span class="n">g_vals</span> <span class="o">=</span> <span class="n">tmp_best_island</span><span class="o">.</span><span class="n">grid_values</span><span class="p">()</span>
        <span class="n">g_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_step_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_threshold</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum threshold for which the &quot;best island&quot; volume is smaller than the target volume</span>

<span class="sd">        :param float start_threshold: island threshold</span>
<span class="sd">        :return float: threhold</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">start_threshold</span> <span class="o">*</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">threshold</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_single_grid</span><span class="o">.</span><span class="n">get_best_island</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">_num_gp</span><span class="p">:</span>
                <span class="n">threshold</span> <span class="o">+=</span> <span class="mf">0.5</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_grid</span><span class="o">.</span><span class="n">get_best_island</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">threshold</span>

<div class="viewcode-block" id="Extractor.extract_volume"><a class="viewcode-back" href="../../result_api.html#hotspots.result.Extractor.extract_volume">[docs]</a>    <span class="k">def</span> <span class="nf">extract_volume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">volume</span><span class="o">=</span><span class="s2">&quot;125&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a HotspotResult with a restricted volume</span>


<span class="sd">        :param int volume: target map volume</span>
<span class="sd">        :return `hotspots.result.Results`: A fresh result object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">volume</span> <span class="o">=</span> <span class="n">volume</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">single_grid</span><span class="o">.</span><span class="n">count_grid</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">_num_gp</span>

        <span class="n">threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_step_down</span><span class="p">(</span><span class="mi">40</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_grow</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final score threshold is: </span><span class="si">{}</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">threshold</span><span class="p">))</span>

        <span class="n">grid_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">best_island</span><span class="o">.</span><span class="n">inverse_single_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_masked_dic</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">Results</span><span class="p">(</span><span class="n">super_grids</span><span class="o">=</span><span class="n">grid_dict</span><span class="p">,</span> <span class="n">protein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hotspot_result</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">step_threshold</span> <span class="o">=</span> <span class="n">threshold</span>
        <span class="k">return</span> <span class="n">r</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Hotspots API 1.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hotspots.result</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Chris Radoux, Peter Curran, Mihaela D. Smilova, Richard A. Sykes, Alicia Higueruelo, Anthony Bradley, Brian D. Marsdend, David R. Spring, Tom L. Blundell, Andrew R. Leach, William R. Pitt, Jason C. Cole.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>