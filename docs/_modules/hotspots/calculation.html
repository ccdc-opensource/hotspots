
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hotspots.calculation &#8212; Hotspots API 1.0.2 documentation</title>
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Hotspots API 1.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hotspots.calculation</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for hotspots.calculation</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">The :mod:`hotspots.calculation` handles the main Fragment Hotspot Maps algorithm. In addition, an alternative pocket burial method, Ghecom, is provided.</span>

<span class="sd">The main classes of the :mod:`hotspots.calculation` module are:</span>

<span class="sd">- :class:`hotspots.calculation.Buriedness`</span>
<span class="sd">- :class:`hotspots.calculation.Runner`</span>

<span class="sd">More information about the Fragment Hotspot Maps method is available from:</span>
<span class="sd">    - Radoux, C.J. et. al., Identifying the Interactions that Determine Fragment Binding at Protein Hotspots J. Med. Chem. 2016, 59 (9), 4314-4325 [dx.doi.org/10.1021/acs.jmedchem.5b01980]</span>

<span class="sd">More information about the Ghecom method is available from:</span>
<span class="sd">    - Kawabata T, Go N. Detection of pockets on protein surfaces using small and large probe spheres to find putative ligand binding sites. Proteins 2007; 68: 516-529</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">multiprocessing</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">system</span><span class="p">,</span> <span class="n">environ</span>
<span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">join</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pkg_resources</span>
<span class="kn">from</span> <span class="nn">ccdc.cavity</span> <span class="kn">import</span> <span class="n">Cavity</span>
<span class="kn">from</span> <span class="nn">ccdc.io</span> <span class="kn">import</span> <span class="n">MoleculeWriter</span><span class="p">,</span> <span class="n">MoleculeReader</span>
<span class="kn">from</span> <span class="nn">ccdc.molecule</span> <span class="kn">import</span> <span class="n">Molecule</span><span class="p">,</span> <span class="n">Coordinates</span>
<span class="kn">from</span> <span class="nn">ccdc.protein</span> <span class="kn">import</span> <span class="n">Protein</span>
<span class="kn">from</span> <span class="nn">ccdc.utilities</span> <span class="kn">import</span> <span class="n">PushDir</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">skimage.morphology</span> <span class="kn">import</span> <span class="n">ball</span>
<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="c1"># from hotspots.protoss import Protoss</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">from</span> <span class="nn">hotspots.atomic_hotspot_calculation</span> <span class="kn">import</span> <span class="n">_AtomicHotspot</span>
<span class="kn">from</span> <span class="nn">hotspots.grid_extension</span> <span class="kn">import</span> <span class="n">Grid</span>
<span class="kn">from</span> <span class="nn">hotspots.hs_utilities</span> <span class="kn">import</span> <span class="n">Helper</span>
<span class="kn">from</span> <span class="nn">hotspots.wrapper_pdb</span> <span class="kn">import</span> <span class="n">PDBResult</span>
<span class="kn">from</span> <span class="nn">hotspots.wrapper_ghecom</span> <span class="kn">import</span> <span class="n">Ghecom</span>
<span class="kn">from</span> <span class="nn">hotspots.result</span> <span class="kn">import</span> <span class="n">Results</span>


<span class="k">class</span> <span class="nc">ExpBuriedness</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">out_grid</span><span class="p">,</span> <span class="n">max_probe_radius</span><span class="o">=</span><span class="mi">11</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prot</span> <span class="o">=</span> <span class="n">prot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_grid</span> <span class="o">=</span> <span class="n">out_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_probe</span> <span class="o">=</span> <span class="n">max_probe_radius</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe_selem_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_probe_selem</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protein_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_from_molecule</span><span class="p">(</span><span class="n">prot</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_generate_probe_selem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a set of structuring elements (i.e. probe spheres) starting from a 3x3 cross (0.5 A radius) probe up</span>
<span class="sd">        to the max probe radius</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">probe_selem_dict</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Small probe</span>

        <span class="n">probe_selem_dict</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># r= probe radius</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_probe</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">probe_selem_dict</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">ball</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">probe_selem_dict</span>

    <span class="k">def</span> <span class="nf">_from_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generate a molecule mask where gp within the vdw radius of the molecule heavy atoms are set to 1.0</span>
<span class="sd">        :param mol: `ccdc.molecule.Molecule`</span>
<span class="sd">        :param padding: int</span>
<span class="sd">        :param scaling: float</span>
<span class="sd">        :return: `hotspots.grid_extension.Grid`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">initalise_grid</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_selem_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">set_sphere</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                             <span class="n">radius</span><span class="o">=</span><span class="n">probe</span> <span class="o">*</span> <span class="n">scaling</span><span class="p">,</span>
                             <span class="n">value</span><span class="o">=</span><span class="n">probe</span><span class="p">,</span>
                             <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span>
                             <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">heavy_atoms</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">set_sphere</span><span class="p">(</span><span class="n">point</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">,</span>
                         <span class="n">radius</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">vdw_radius</span><span class="p">,</span>
                         <span class="n">value</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
                         <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;replace&#39;</span><span class="p">,</span>
                         <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>

        <span class="n">out_bound_box</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_grid</span><span class="o">.</span><span class="n">bounding_box</span>
        <span class="n">origin_indices</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">point_to_indices</span><span class="p">(</span><span class="n">out_bound_box</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">far_indices</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">point_to_indices</span><span class="p">(</span><span class="n">out_bound_box</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">region</span> <span class="o">=</span> <span class="n">origin_indices</span> <span class="o">+</span> <span class="n">far_indices</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">sub_grid</span><span class="p">(</span><span class="n">region</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_close_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">probe</span><span class="p">):</span>

        <span class="n">g_array</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">closed_array</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">g_array</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_selem_dict</span><span class="p">[</span><span class="n">probe</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Grid</span><span class="o">.</span><span class="n">array_to_grid</span><span class="p">(</span><span class="n">closed_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">g</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_multiscale_closing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">):</span>

        <span class="c1"># probe_sizes.reverse()</span>
        <span class="n">all_g</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">prot_mask</span> <span class="o">=</span> <span class="n">g</span> <span class="o">&gt;</span> <span class="mi">90</span>

        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_selem_dict</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">all_g</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">all_g</span> <span class="o">=</span> <span class="n">prot_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="n">probe_mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">g</span> <span class="o">&lt;</span> <span class="n">probe</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">|</span> <span class="p">(</span><span class="n">prot_mask</span><span class="p">)</span>

            <span class="n">probe_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close_grid</span><span class="p">(</span><span class="n">probe_mask</span><span class="p">,</span> <span class="n">probe</span><span class="p">)</span>
            <span class="n">novel</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">all_g</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">g</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">all_g</span> <span class="o">+=</span> <span class="p">(</span><span class="n">probe_mask</span> <span class="o">*</span> <span class="n">novel</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_probe</span> <span class="o">-</span> <span class="n">probe</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">all_g</span> <span class="o">*</span> <span class="p">(</span><span class="n">prot_mask</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_open_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">probe</span><span class="p">):</span>

        <span class="n">g_array</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">opened_array</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">binary_opening</span><span class="p">(</span><span class="n">g_array</span><span class="p">,</span> <span class="n">structure</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">probe_selem_dict</span><span class="p">[</span><span class="n">probe</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">Grid</span><span class="o">.</span><span class="n">array_to_grid</span><span class="p">(</span><span class="n">opened_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">g</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">buriedness_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">closed_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multiscale_closing</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">protein_grid</span><span class="p">)</span>
        <span class="n">out_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_open_grid</span><span class="p">(</span><span class="n">closed_g</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">closed_g</span>
        <span class="n">out_array</span> <span class="o">=</span> <span class="n">out_g</span><span class="o">.</span><span class="n">get_array</span><span class="p">()</span>
        <span class="n">scaled_g</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">initalise_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_grid</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">resize</span><span class="p">(</span><span class="n">out_array</span><span class="p">,</span> <span class="n">scaled_g</span><span class="o">.</span><span class="n">nsteps</span><span class="p">,</span> <span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Future tweaking here</span>
        <span class="n">final_array</span> <span class="o">=</span> <span class="n">scaled_array</span>
        <span class="k">return</span> <span class="n">Grid</span><span class="o">.</span><span class="n">array_to_grid</span><span class="p">(</span><span class="n">final_array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span> <span class="n">scaled_g</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_WeightedResult</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    private class</span>

<span class="sd">    A class to handle the weighted grid results</span>

<span class="sd">    :param str identifier: identifier, default is the probe identifier assigned at the Atomic Hotspot Calculation stage</span>
<span class="sd">    :param `ccdc.utilities.Grid` grid: result grid</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">identifier</span><span class="p">,</span> <span class="n">grid</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="n">identifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>


<span class="k">class</span> <span class="nc">_SampleGrid</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    private class</span>

<span class="sd">    class to handle sampled grids</span>

<span class="sd">    :param name: str, name of probe (donor, acceptor, apolar, positive, negative)</span>
<span class="sd">    :param grid: a :class: `ccdc.utilities.Grid` instance</span>
<span class="sd">    :param atom_predicate: atom_predicate will be used to select atoms of a molecule for sampling</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">atom_predicate</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">atom_predicate</span> <span class="o">=</span> <span class="n">atom_predicate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_coordinates</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        provides a coordinate list of atoms to be scored be scored in the SampleGrid</span>
<span class="sd">        :param coord: tup, (float(x), float(y), float(z)), set of atomic coordinates for &quot;active&quot; coordinates</span>
<span class="sd">        :param trans: tup, (float(x), float(y), float(z)), set of translations to translate probes to points</span>
<span class="sd">        above threshold</span>
<span class="sd">        :return: list of tup</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">coord</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">trans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">trans</span><span class="p">))]</span>

    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coordinate_list</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        score Molecule in grids for which it has active atoms</span>
<span class="sd">        :param coordinate_list: list, set of coordinates of translated and rotated probe atoms to be scored</span>
<span class="sd">        :param trans:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">add_coordinates</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">trans</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coordinate_list</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">RuntimeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">set_molecule</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mol</span><span class="p">,</span> <span class="n">polar_contribution</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        set which atoms match the grid</span>
<span class="sd">        probes with polar atoms contribute do not contribute to apolar maps as this leads to artefacts</span>

<span class="sd">        :param mol:</span>
<span class="sd">        :param polar_contribution:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mol</span> <span class="o">=</span> <span class="n">mol</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s1">&#39;apolar&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">polar_contribution</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">mol</span><span class="o">.</span><span class="n">atoms</span>
                                                                     <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_active_atoms&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_active_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_predicate</span><span class="p">(</span><span class="n">a</span><span class="p">)]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_donor</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a donor</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom classification is &quot;donor&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_acceptor</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a acceptor</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom classification is &quot;acceptor&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_apolar</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a apolar</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom classification is &quot;apolar&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">atomic_symbol</span> <span class="o">==</span> <span class="s2">&quot;Xe&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_positive</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a positively charged</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom is positively charged</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_negative</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is a negatively charged</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom is negatively charged</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&lt;</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">is_aromatic</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns true if a given atom is aromatic</span>

<span class="sd">        :param a: a `ccdc.molecule.Atom` instance</span>
<span class="sd">        :return: bool, true if the atom is aromatic</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">atomic_symbol</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">is_cyclic</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">atom_type</span> <span class="o">==</span> <span class="s1">&#39;aromatic&#39;</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">bonds</span><span class="p">)</span>


<div class="viewcode-block" id="Runner"><a class="viewcode-back" href="../../calculation_api.html#hotspots.calculation.Runner">[docs]</a><span class="k">class</span> <span class="nc">Runner</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for running the Fragment Hotspot Map calculation</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Runner.Settings"><a class="viewcode-back" href="../../calculation_api.html#hotspots.calculation.Runner.Settings">[docs]</a>    <span class="k">class</span> <span class="nc">Settings</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adjusts the default settings for the calculation</span>

<span class="sd">        :param int nrotations: number of rotations (keep it below 10**6)</span>
<span class="sd">        :param float apolar_translation_threshold: translate probe to grid points above this threshold. Give lower values for greater sampling. Default 15</span>
<span class="sd">        :param float polar_translation_threshold: translate probe to grid points above this threshold. Give lower values for greater sampling. Default 15</span>
<span class="sd">        :param bool polar_contributions: allow carbon atoms of probes with polar atoms to contribute to the apolar output map.</span>
<span class="sd">        :param bool return_probes: Generate a sorted list of molecule objects, corresponding to probe poses</span>
<span class="sd">        :param bool sphere_maps: When setting the probe score on the output maps, set it for a sphere (radius 1.5) instead of a single point.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nrotations</span><span class="o">=</span><span class="mi">3000</span><span class="p">,</span> <span class="n">apolar_translation_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">polar_translation_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span>
                     <span class="n">polar_contributions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sphere_maps</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nrotations</span> <span class="o">=</span> <span class="n">nrotations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">apolar_translation_threshold</span> <span class="o">=</span> <span class="n">apolar_translation_threshold</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polar_translation_threshold</span> <span class="o">=</span> <span class="n">polar_translation_threshold</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polar_contributions</span> <span class="o">=</span> <span class="n">polar_contributions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">return_probes</span> <span class="o">=</span> <span class="n">return_probes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sphere_maps</span> <span class="o">=</span> <span class="n">sphere_maps</span>

        <span class="nd">@property</span>
        <span class="k">def</span> <span class="nf">_num_gp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            number of grid point for a given volume</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">nrotations</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span></div>

    <span class="k">class</span> <span class="nc">_Sampler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Samples one or more grids with a probe molecule</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">grids</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Settings used to run fragment-hotspot-maps script</span>

<span class="sd">            :param grids: list, list of :class:`ccdc.utilities.Grid` instances</span>
<span class="sd">            :param kw: &#39;settings&#39;</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="o">=</span> <span class="n">grids</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_dic</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grid_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span>
            <span class="n">settings</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;settings&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">probe_grids</span> <span class="o">=</span> <span class="p">[</span><span class="n">_SampleGrid</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">copy_and_clear</span><span class="p">(),</span> <span class="n">g</span><span class="o">.</span><span class="n">atom_predicate</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">get_priority_atom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Select priority atom. Select polar atom. If multiple polar atoms, select the one furthest from the centre of</span>
<span class="sd">            geometry. If no polar atoms, select atom furthest from centre of geometry</span>

<span class="sd">            :param molecule: a :class: `ccdc.molecule.Molecule` instance</span>
<span class="sd">            :return: a :class: `ccdc.molecule.Molecule` instance, str atom type</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">centre_of_geometry</span><span class="p">()</span>
            <span class="n">polar_atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">is_donor</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">]</span>
            <span class="n">atom_by_distance</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polar_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">polar_atoms</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Helper</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
                    <span class="n">atom_by_distance</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">molecule</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">Helper</span><span class="o">.</span><span class="n">get_distance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">coordinates</span><span class="p">)</span>
                    <span class="n">atom_by_distance</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

            <span class="n">greatest_distance</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">atom_by_distance</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">priority_atom</span> <span class="o">=</span> <span class="n">atom_by_distance</span><span class="p">[</span><span class="n">greatest_distance</span><span class="p">]</span>

            <span class="n">pa_type</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;negative&quot;</span>
                <span class="k">elif</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">formal_charge</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;positive&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;acceptor&quot;</span>
                <span class="k">elif</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">is_donor</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;donor&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">pa_type</span> <span class="o">=</span> <span class="s2">&quot;apolar&quot;</span>

            <span class="k">return</span> <span class="n">priority_atom</span><span class="p">,</span> <span class="n">pa_type</span>

        <span class="k">def</span> <span class="nf">get_translation_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority_atom_type</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            returns a list of coordinates that are greater than the threshold, that the probe will be translated to</span>

<span class="sd">            :param priority_atom_type: str, atomic interaction type</span>
<span class="sd">            :return: list, list of :class: `ccdc.molecule.Molecule` instances</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">translate_probe</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">wg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_dic</span><span class="p">[</span><span class="n">priority_atom_type</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">priority_atom_type</span> <span class="o">==</span> <span class="s1">&#39;apolar&#39;</span><span class="p">:</span>
                <span class="n">translation_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">apolar_translation_threshold</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">translation_threshold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">polar_translation_threshold</span>
            <span class="n">hs</span> <span class="o">=</span> <span class="n">wg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">islands</span><span class="p">(</span><span class="n">translation_threshold</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">hs</span><span class="p">:</span>
                <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span><span class="p">,</span> <span class="n">nz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">nsteps</span>

                <span class="n">maxima</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">indices_to_point</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ny</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span>
                          <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">translation_threshold</span><span class="p">]</span>

                <span class="n">translate_probe</span> <span class="o">=</span> <span class="n">translate_probe</span> <span class="o">+</span> <span class="n">maxima</span>
            <span class="k">return</span> <span class="n">translate_probe</span>

        <span class="k">def</span> <span class="nf">generate_rand_quaternions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a list of random quaternions. Length matches settings.nrotations</span>

<span class="sd">            :return: tup, (a,b,c,d)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">quaternions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">nrotations</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">nrotations</span><span class="p">:</span>
                    <span class="n">r1</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">r2</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">s1</span> <span class="o">=</span> <span class="n">r1</span> <span class="o">*</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span> <span class="o">*</span> <span class="n">r2</span>
                    <span class="k">if</span> <span class="n">s1</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">r3</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                        <span class="n">r4</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

                        <span class="n">s2</span> <span class="o">=</span> <span class="n">r3</span> <span class="o">*</span> <span class="n">r3</span> <span class="o">+</span> <span class="n">r4</span> <span class="o">*</span> <span class="n">r4</span>
                        <span class="k">if</span> <span class="n">s2</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)),</span> <span class="n">r4</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s1</span><span class="p">)</span> <span class="o">/</span> <span class="n">s2</span><span class="p">)))</span>
                            <span class="n">quaternions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>

                            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">quaternions</span>

        <span class="nd">@staticmethod</span>
        <span class="k">def</span> <span class="nf">score</span><span class="p">(</span><span class="n">values</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate geometric mean of scores</span>

<span class="sd">            :param values: float, scores of atoms in probe</span>
<span class="sd">            :return: float, geometric mean of probe atom scores</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">return</span> <span class="n">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">sample_pose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">active_atoms_dic</span><span class="p">,</span> <span class="n">probe</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return a pose score (as defined by the score(self,dic) function) and a dictionary of atom:scores</span>

<span class="sd">            :param trans: list of translations</span>
<span class="sd">            :param active_atoms_dic: dict {&quot;interaction type&quot;: &quot;atoms to be scored&quot;}</span>
<span class="sd">            :param probe: str, interaction_type</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span> <span class="ow">or</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">mol</span><span class="o">.</span><span class="n">atoms</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;positive&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">6</span> <span class="o">/</span> <span class="nb">len</span><span class="p">([</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">atomic_symbol</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">]))</span>

                <span class="n">apolar_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span>
                                 <span class="nb">len</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;apolar&quot;</span><span class="p">]</span> <span class="o">*</span> <span class="n">weight</span>
                <span class="n">charged_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span>
                                  <span class="nb">len</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">g</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;apolar&quot;</span><span class="p">]</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">apolar_values</span> <span class="o">+</span> <span class="n">charged_values</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">trans</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span> <span class="k">if</span>
                          <span class="nb">len</span><span class="p">(</span><span class="n">active_atoms_dic</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">scores</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sublist</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">score</span><span class="p">(</span><span class="n">scores</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">update_out_grids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">active_coordinates_dic</span><span class="p">,</span> <span class="n">trans</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            For active atoms for a given grid, set closest grid point value to score, unless already set to a higher</span>
<span class="sd">            value</span>

<span class="sd">            :param score: float, score of a given probe</span>
<span class="sd">            :param active_coordinates_dic:</span>
<span class="sd">            :param trans: list of translations</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_grids</span><span class="p">:</span>
                <span class="n">actives</span> <span class="o">=</span> <span class="n">active_coordinates_dic</span><span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">actives</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">actives</span><span class="p">:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">add_coordinates</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">trans</span><span class="p">)</span>
                    <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">point_to_indices</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">orig_value</span> <span class="o">=</span> <span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="c1">#</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">sphere_maps</span><span class="p">:</span>
                        <span class="c1"># pg.grid.set_sphere(coords, 2, score, mode=&#39;max&#39;)</span>
                        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">orig_value</span><span class="p">:</span>
                            <span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">set_sphere</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">score</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">set_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">orig_value</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">get_active_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns a dictionary of {grid_name:[Coordinates]}</span>

<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">active_coords_dic</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">coordinates</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">_active_atoms</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">active_coords_dic</span>

        <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">molecule</span><span class="p">,</span> <span class="n">probe</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Sample the grids according to the settings</span>

<span class="sd">            :param molecule:</span>
<span class="sd">            :param probe: str, interaction type, (donor, acceptor, negative, positive, apolar)</span>
<span class="sd">            :return:</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">priority_atom</span><span class="p">,</span> <span class="n">priority_atom_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_priority_atom</span><span class="p">(</span><span class="n">molecule</span><span class="p">)</span>
            <span class="n">translate_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_translation_points</span><span class="p">(</span><span class="n">priority_atom_type</span><span class="p">)</span>
            <span class="n">molecule</span><span class="o">.</span><span class="n">remove_hydrogens</span><span class="p">()</span>
            <span class="n">quaternions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_rand_quaternions</span><span class="p">()</span>
            <span class="n">high_scoring_probes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">    nRotations:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">quaternions</span><span class="p">),</span> <span class="s2">&quot;nTranslations:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">translate_points</span><span class="p">),</span> <span class="s2">&quot;probename:&quot;</span><span class="p">,</span> <span class="n">probe</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grids</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">set_molecule</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_grids</span><span class="p">:</span>
                <span class="n">g</span><span class="o">.</span><span class="n">set_molecule</span><span class="p">(</span><span class="n">molecule</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">polar_contributions</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">quaternions</span><span class="p">):</span>
                <span class="n">molecule</span><span class="o">.</span><span class="n">apply_quaternion</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
                <span class="n">priority_atom_coordinates</span> <span class="o">=</span> <span class="n">priority_atom</span><span class="o">.</span><span class="n">coordinates</span>
                <span class="n">active_coordinates_dic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_active_coordinates</span><span class="p">()</span>

                <span class="k">for</span> <span class="n">priority_atom_point</span> <span class="ow">in</span> <span class="n">translate_points</span><span class="p">:</span>

                    <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">priority_atom_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">priority_atom_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                                   <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">priority_atom_coordinates</span><span class="p">))]</span>

                    <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_pose</span><span class="p">(</span><span class="n">translation</span><span class="p">,</span> <span class="n">active_coordinates_dic</span><span class="p">,</span> <span class="n">probe</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">update_out_grids</span><span class="p">(</span><span class="n">score</span><span class="p">,</span> <span class="n">active_coordinates_dic</span><span class="p">,</span> <span class="n">translation</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">return_probes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">score</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="mi">14</span><span class="p">:</span>
                            <span class="n">m</span> <span class="o">=</span> <span class="n">molecule</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                            <span class="n">m</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">translation</span><span class="p">)</span>
                            <span class="n">m</span><span class="o">.</span><span class="n">identifier</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>

                            <span class="k">try</span><span class="p">:</span>
                                <span class="n">high_scoring_probes</span><span class="p">[</span><span class="n">score</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                                <span class="n">high_scoring_probes</span><span class="p">[</span><span class="n">score</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">return_probes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">sampled_probes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">high_scoring_probes</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">(),</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                    <span class="n">sampled_probes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">high_scoring_probes</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Returned probes = &#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampled_probes</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampled_probes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sampled_probes</span><span class="p">[:</span><span class="mi">10000</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">sampled_probes</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="n">settings</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">protein</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        protein submitted for calculation</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_protein</span>

    <span class="nd">@protein</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">protein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prot</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        protein submitted for calculation</span>
<span class="sd">        :param `ccdc.protein.Protein` prot: protein</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prot</span><span class="p">,</span> <span class="n">Protein</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_protein</span> <span class="o">=</span> <span class="n">prot</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;`ccdc.protein.Protein` must be supplied. Hint: Use Protein.from_file()&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">charged_probes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, True if charged features are to be calculated</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_charged_probes</span>

    <span class="nd">@charged_probes</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">charged_probes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, True if charged features are to be calculated</span>
<span class="sd">        :param bool option: (default = True)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">option</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">bool</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_charged_probes</span> <span class="o">=</span> <span class="n">option</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expecting a bool, got </span><span class="si">{}</span><span class="s2"> instead&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">option</span><span class="p">)))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">probe_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, change probe size. NB: feature has not been tested.</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_probe_size</span>

    <span class="nd">@probe_size</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">probe_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, change probe size. NB: feature has not been tested.</span>
<span class="sd">        :param int size: number of heavy atoms contain within the molecular probes (integer between 3 and 8)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_probe_size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Probe size must be an integer between 3-7&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">buriedness_method</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, pocket detection method. (default = &quot;ghecom&quot;)</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buriedness_method</span>

    <span class="nd">@buriedness_method</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">buriedness_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, pocket detection method. (default = &quot;ghecom&quot;)</span>
<span class="sd">        :param str method: either &#39;ghecom&#39; or &#39;ligsite&#39;</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ghecom&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;linux&#39;</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;linux2&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;GHECOM_EXE&#39;</span> <span class="ow">in</span> <span class="n">environ</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buriedness_method</span> <span class="o">=</span> <span class="n">method</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">EnvironmentError</span><span class="p">(</span><span class="s2">&quot;Must set Ghecom environment variable&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s1">&#39;Ghecom is only supported on linux&#39;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ghecom_internal&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buriedness_method</span> <span class="o">=</span> <span class="n">method</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ligsite&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;linux&#39;</span> <span class="ow">or</span> <span class="n">sys</span><span class="o">.</span><span class="n">platform</span> <span class="o">==</span> <span class="s1">&#39;linux2&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RECOMMENDATION: you have chosen LIGSITE as buriedness method, ghecom is recommended&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buriedness_method</span> <span class="o">=</span> <span class="n">method</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Buriedness method must be &#39;ghecom&#39; (default) or &#39;ligsite&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cavities</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, cavities supplied to the calculation</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span>

    <span class="nd">@cavities</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">cavities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        optional settings, cavities supplied to the calculation</span>
<span class="sd">        :param list or Coordinate or `ccdc.molecule.Molecule` or `ccdc.cavity.Cavity`: cavity information provided</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Coordinates</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="n">obj</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Molecule</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">centre_of_geometry</span><span class="p">()</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cavity</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="p">[</span><span class="n">Helper</span><span class="o">.</span><span class="n">cavity_centroid</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING! Failed to detected cavity, Atomic Hotspot detection to run on whole protein&quot;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">centre_of_geometry</span><span class="p">()]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Cavity</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="p">[</span><span class="n">Helper</span><span class="o">.</span><span class="n">cavity_centroid</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;WARNING! Failed to detected cavity, Atomic Hotspot detection to run on whole protein&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cavities</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">nprocesses</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        number of processes used in parallelisation</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nprocesses</span>

    <span class="nd">@nprocesses</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">nprocesses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        number of processes used in parallelisation</span>
<span class="sd">        :param int num: number of processor</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">())):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nprocesses</span> <span class="o">=</span> <span class="n">num</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">OSError</span><span class="p">(</span><span class="s2">&quot;CPU count = </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">multiprocessing</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampler_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sampler settings</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampler_settings</span>

    <span class="nd">@sampler_settings</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sampler_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sampler settings</span>
<span class="sd">        :param `hotspots.calculation.Runner.Settings` settings: adjust run settings</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">settings</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampler_settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampler_settings</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_get_weighted_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        private method</span>

<span class="sd">        weight superstar output by burriedness</span>
<span class="sd">        :return: a list of :class:`WeightedResult` instances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">:</span>
            <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">common_grid</span><span class="p">([</span><span class="n">s</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">],</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">weighted_grid</span> <span class="o">=</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_WeightedResult</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">identifier</span><span class="p">,</span> <span class="n">weighted_grid</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">results</span>

    <span class="k">def</span> <span class="nf">_get_out_maps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probe</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">,</span> <span class="n">return_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        private method</span>

<span class="sd">        organises the sampling of weighted superstar maps by molecular probes</span>
<span class="sd">        :param str probe: probe identifier set in the Atomic Hotspot calculation</span>
<span class="sd">        :param dict grid_dict: dictionary with key = probe identifier and value = `hotspots.grid_extension.Grid`</span>
<span class="sd">        :param bool return_probes: optional, bool indicating if probe molecules should be returned</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">donor_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;donor&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;donor&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_donor</span><span class="p">)</span>
        <span class="n">acceptor_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;acceptor&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;acceptor&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_acceptor</span><span class="p">)</span>
        <span class="n">apolar_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;apolar&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;apolar&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_apolar</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="n">negative_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;negative&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;negative&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_negative</span><span class="p">)</span>
            <span class="n">positive_grid</span> <span class="o">=</span> <span class="n">_SampleGrid</span><span class="p">(</span><span class="s1">&#39;positive&#39;</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">[</span><span class="s1">&#39;positive&#39;</span><span class="p">],</span> <span class="n">_SampleGrid</span><span class="o">.</span><span class="n">is_positive</span><span class="p">)</span>

        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;settings&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sampler</span><span class="p">(</span><span class="n">apolar_grid</span><span class="p">,</span> <span class="n">donor_grid</span><span class="p">,</span> <span class="n">acceptor_grid</span><span class="p">,</span> <span class="n">negative_grid</span><span class="p">,</span> <span class="n">positive_grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Sampler</span><span class="p">(</span><span class="n">apolar_grid</span><span class="p">,</span> <span class="n">donor_grid</span><span class="p">,</span> <span class="n">acceptor_grid</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="n">probe_path</span> <span class="o">=</span> <span class="n">pkg_resources</span><span class="o">.</span><span class="n">resource_filename</span><span class="p">(</span><span class="s1">&#39;hotspots&#39;</span><span class="p">,</span> <span class="s1">&#39;probes/&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;negative&quot;</span> <span class="ow">or</span> <span class="n">probe</span> <span class="o">==</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">MoleculeReader</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">probe_path</span><span class="p">,</span> <span class="s2">&quot;rotate-</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_flat.mol2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="s2">&quot;test&quot;</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mol</span> <span class="o">=</span> <span class="n">MoleculeReader</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">probe_path</span><span class="p">,</span> <span class="s2">&quot;rotate-</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_flat.mol2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mol</span> <span class="o">=</span> <span class="n">MoleculeReader</span><span class="p">(</span><span class="n">join</span><span class="p">(</span><span class="n">probe_path</span><span class="p">,</span> <span class="s2">&quot;rotate-</span><span class="si">{}</span><span class="s2">_</span><span class="si">{}</span><span class="s2">_flat.mol2&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">probes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">mol</span><span class="p">,</span> <span class="n">probe</span><span class="o">=</span><span class="n">probe</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">pg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">probe_grids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">probe</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pg</span><span class="o">.</span><span class="n">grid</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">return_probes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">probes</span>

    <span class="k">def</span> <span class="nf">_calc_hotspots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        handles the organisation of the hotspot calculation</span>
<span class="sd">        :param return_probes: optional, bool indicating if probe molecules should be returned</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start atomic hotspot detection</span><span class="se">\n</span><span class="s2">        Processors: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nprocesses</span><span class="p">))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">_AtomicHotspot</span><span class="p">()</span>
        <span class="n">a</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">atomic_probes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;apolar&quot;</span><span class="p">:</span> <span class="s2">&quot;AROMATIC CH CARBON&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;donor&quot;</span><span class="p">:</span> <span class="s2">&quot;UNCHARGED NH NITROGEN&quot;</span><span class="p">,</span>
                                    <span class="s2">&quot;acceptor&quot;</span><span class="p">:</span> <span class="s2">&quot;CARBONYL OXYGEN&quot;</span><span class="p">}</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">atomic_probes</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;negative&quot;</span><span class="p">:</span> <span class="s2">&quot;CARBOXYLATE OXYGEN&quot;</span><span class="p">,</span> <span class="s2">&quot;positive&quot;</span><span class="p">:</span> <span class="s2">&quot;CHARGED NH NITROGEN&quot;</span><span class="p">}</span>

        <span class="n">probe_types</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">atomic_probes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">protein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">,</span>
                                           <span class="n">nthreads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nprocesses</span><span class="p">,</span>
                                           <span class="n">cavity_origins</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cavities</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">clear_tmp</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">temp_dir</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Atomic hotspot detection complete</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start buriedness calculation&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ghecom&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    method: Ghecom&quot;</span><span class="p">)</span>
            <span class="n">out_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">buriedness</span><span class="o">.</span><span class="n">copy_and_clear</span><span class="p">()</span>

            <span class="n">ghecom</span> <span class="o">=</span> <span class="n">Ghecom</span><span class="p">()</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">ghecom</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">ghecom</span><span class="o">.</span><span class="n">pdb_to_grid</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">out_grid</span><span class="p">)</span>

            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">ghecom</span><span class="o">.</span><span class="n">temp</span><span class="p">)</span> <span class="c1"># probs not needed</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ghecom_internal&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    method: Internal version Ghecom&quot;</span><span class="p">)</span>
            <span class="n">out_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">buriedness</span><span class="o">.</span><span class="n">copy_and_clear</span><span class="p">()</span>
            <span class="n">b</span> <span class="o">=</span> <span class="n">ExpBuriedness</span><span class="p">(</span><span class="n">prot</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">,</span> <span class="n">out_grid</span><span class="o">=</span><span class="n">out_grid</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">buriedness_grid</span><span class="p">()</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness_method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;ligsite&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;    method: LIGSITE&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">get_single_grid</span><span class="p">(</span><span class="n">grd_dict</span><span class="o">=</span><span class="p">{</span><span class="n">s</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">buriedness</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">},</span>
                                                   <span class="n">mask</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_weighted_maps</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Buriedness calcualtion complete</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start sampling&quot;</span><span class="p">)</span>
        <span class="n">grid_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="n">probe_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">return_probes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">ps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_out_maps</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">,</span> <span class="n">return_probes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampled_probes</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">probe</span><span class="p">:</span> <span class="n">ps</span><span class="p">})</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_get_out_maps</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sampling complete</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepare_protein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protoss</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        default protein preparation settings on the protein</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">remove_all_waters</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lig</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">ligands</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">remove_ligand</span><span class="p">(</span><span class="n">lig</span><span class="o">.</span><span class="n">identifier</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">remove_all_metals</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">protoss</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="o">.</span><span class="n">add_hydrogens</span><span class="p">()</span>

<div class="viewcode-block" id="Runner.from_superstar"><a class="viewcode-back" href="../../calculation_api.html#hotspots.calculation.Runner.from_superstar">[docs]</a>    <span class="k">def</span> <span class="nf">from_superstar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protein</span><span class="p">,</span> <span class="n">superstar_grids</span><span class="p">,</span> <span class="n">buriedness</span><span class="p">,</span> <span class="n">charged_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">probe_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span>
                       <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clear_tmp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        calculate hotspot maps from precalculated superstar maps. This enables more effective parallelisation and reuse</span>
<span class="sd">        of object such as the Buriedness grids</span>

<span class="sd">        :param protein: a :class:`ccdc.protein.Protein` instance</span>
<span class="sd">        :param superstar_grids: a :class:`hotspots.atomic_hotspot_calculation._AtomicHotspotResult` instance</span>
<span class="sd">        :param buriedness: a :class:`hotspots.grid_extension.Grid` instance</span>
<span class="sd">        :param bool charged_probes: If True, include positive and negative probes</span>
<span class="sd">        :param int probe_size: Size of probe in number of heavy atoms (3-8 atoms)</span>
<span class="sd">        :param settings: `hotspots.calculation.Runner.Settings` settings: holds the sampler settings</span>
<span class="sd">        :param bool clear_tmp: If True, clear the temporary directory</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span> <span class="o">=</span> <span class="n">superstar_grids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span><span class="o">.</span><span class="n">identifier</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">buriedness</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">protein</span> <span class="o">=</span> <span class="n">protein</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span> <span class="o">=</span> <span class="n">charged_probes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="n">probe_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_tmp</span> <span class="o">=</span> <span class="n">clear_tmp</span>

        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="n">settings</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_weighted_maps</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Start sampling&quot;</span><span class="p">)</span>
        <span class="n">grid_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">w</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">w</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">probe</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">probe_types</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_get_out_maps</span><span class="p">(</span><span class="n">probe</span><span class="p">,</span> <span class="n">grid_dict</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Sampling complete</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Runtime = </span><span class="si">{}</span><span class="s2">seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Results</span><span class="p">(</span><span class="n">super_grids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span>
                       <span class="n">protein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">,</span>
                       <span class="n">buriedness</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">)</span></div>

<div class="viewcode-block" id="Runner.from_protein"><a class="viewcode-back" href="../../calculation_api.html#hotspots.calculation.Runner.from_protein">[docs]</a>    <span class="k">def</span> <span class="nf">from_protein</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protein</span><span class="p">,</span> <span class="n">charged_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">probe_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">buriedness_method</span><span class="o">=</span><span class="s1">&#39;ghecom&#39;</span><span class="p">,</span>
                     <span class="n">cavities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">nprocesses</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">buriedness_grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clear_tmp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generates a result from a protein</span>

<span class="sd">        :param protein: a :class:`ccdc.protein.Protein` instance</span>
<span class="sd">        :param bool charged_probes: If True include positive and negative probes</span>
<span class="sd">        :param int probe_size: Size of probe in number of heavy atoms (3-8 atoms)</span>
<span class="sd">        :param str buriedness_method: Either &#39;ghecom&#39; or &#39;ligsite&#39;</span>
<span class="sd">        :param cavities: Coordinate or `ccdc.cavity.Cavity` or `ccdc.molecule.Molecule` or list specifying the cavity or cavities on which the calculation should be run</span>
<span class="sd">        :param int nprocesses: number of CPU&#39;s used</span>
<span class="sd">        :param `hotspots.calculation.Runner.Settings` settings: holds the sampler settings</span>
<span class="sd">        :param `ccdc.utilities.Grid` buriedness_grid: pre-calculated buriedness grid</span>
<span class="sd">        :return: a :class:`hotspots.result.Results` instance</span>


<span class="sd">        &gt;&gt;&gt; from ccdc.protein import Protein</span>
<span class="sd">        &gt;&gt;&gt; from hotspots.calculation import Runner</span>

<span class="sd">        &gt;&gt;&gt; protein = Protein.from_file(&lt;path_to_protein&gt;)</span>

<span class="sd">        &gt;&gt;&gt; runner = Runner()</span>
<span class="sd">        &gt;&gt;&gt; settings = Runner.Settings()</span>
<span class="sd">        &gt;&gt;&gt; settings.nrotations = 1000  # fewer rotations increase speed at the expense of accuracy</span>
<span class="sd">        &gt;&gt;&gt; runner.from_protein(protein, nprocesses=3, settings=settings)</span>
<span class="sd">        Result()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span> <span class="o">=</span> <span class="n">buriedness_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protein</span> <span class="o">=</span> <span class="n">protein</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span> <span class="o">=</span> <span class="n">charged_probes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="n">probe_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness_method</span> <span class="o">=</span> <span class="n">buriedness_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cavities</span> <span class="o">=</span> <span class="n">cavities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_tmp</span> <span class="o">=</span> <span class="n">clear_tmp</span>

        <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cavities</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nprocesses</span> <span class="o">=</span> <span class="n">nprocesses</span>
        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="n">settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_hotspots</span><span class="p">()</span>  <span class="c1"># return probes = False by default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Runtime = </span><span class="si">{}</span><span class="s2">seconds&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Results</span><span class="p">(</span><span class="n">super_grids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span>
                       <span class="n">protein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">,</span>
                       <span class="n">buriedness</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">,</span>
                       <span class="n">superstar</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">},</span>
                       <span class="n">weighted_superstar</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span><span class="p">})</span></div>

<div class="viewcode-block" id="Runner.from_pdb"><a class="viewcode-back" href="../../calculation_api.html#hotspots.calculation.Runner.from_pdb">[docs]</a>    <span class="k">def</span> <span class="nf">from_pdb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pdb_code</span><span class="p">,</span> <span class="n">charged_probes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">probe_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">buriedness_method</span><span class="o">=</span><span class="s1">&#39;ghecom&#39;</span><span class="p">,</span> <span class="n">nprocesses</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                 <span class="n">cavities</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">settings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">clear_tmp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        generates a result from a pdb code</span>

<span class="sd">        :param str pdb_code: PDB code</span>
<span class="sd">        :param bool charged_probes: If True include positive and negative probes</span>
<span class="sd">        :param int probe_size: Size of probe in number of heavy atoms (3-8 atoms)</span>
<span class="sd">        :param str buriedness_method: Either &#39;ghecom&#39; or &#39;ligsite&#39;</span>
<span class="sd">        :param int nprocesses: number of CPU&#39;s used</span>
<span class="sd">        :param `hotspots.calculation.Runner.Settings` settings: holds the calculation settings</span>
<span class="sd">        :return: a :class:`hotspots.result.Result` instance</span>


<span class="sd">        &gt;&gt;&gt; from hotspots.calculation import Runner</span>

<span class="sd">        &gt;&gt;&gt; runner = Runner()</span>
<span class="sd">        &gt;&gt;&gt; runner.from_pdb(&quot;1hcl&quot;)</span>
<span class="sd">        Result()</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">protoss</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="c1"># if  protoss is True:</span>
        <span class="c1">#     protoss = Protoss(out_dir=tmp)</span>
        <span class="c1">#     self.protein = protoss.add_hydrogens(pdb_code).protein</span>
        <span class="c1">#</span>
        <span class="c1"># else:</span>
        <span class="n">PDBResult</span><span class="p">(</span><span class="n">identifier</span><span class="o">=</span><span class="n">pdb_code</span><span class="p">)</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">out_dir</span><span class="o">=</span><span class="n">tmp</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">.pdb&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pdb_code</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">protein</span> <span class="o">=</span> <span class="n">Protein</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_protein</span><span class="p">(</span><span class="n">protoss</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">charged_probes</span> <span class="o">=</span> <span class="n">charged_probes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">probe_size</span> <span class="o">=</span> <span class="n">probe_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buriedness_method</span> <span class="o">=</span> <span class="n">buriedness_method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_tmp</span> <span class="o">=</span> <span class="n">clear_tmp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cavities</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">cavities</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cavities</span> <span class="o">=</span> <span class="n">Cavity</span><span class="o">.</span><span class="n">from_pdb_file</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nprocesses</span> <span class="o">=</span> <span class="n">nprocesses</span>

        <span class="k">if</span> <span class="n">settings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Settings</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span> <span class="o">=</span> <span class="n">settings</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_settings</span><span class="o">.</span><span class="n">return_probes</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;here&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_hotspots</span><span class="p">(</span><span class="n">return_probes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_calc_hotspots</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span> <span class="o">=</span> <span class="p">{</span><span class="n">p</span><span class="p">:</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_grids</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="k">if</span> <span class="n">clear_tmp</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Results</span><span class="p">(</span><span class="n">super_grids</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">super_grids</span><span class="p">,</span>
                       <span class="n">protein</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">protein</span><span class="p">,</span>
                       <span class="n">buriedness</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buriedness</span><span class="p">,</span>
                       <span class="n">superstar</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">superstar_grids</span><span class="p">},</span>
                       <span class="n">weighted_superstar</span><span class="o">=</span><span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">identifier</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">grid</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">weighted_grids</span><span class="p">})</span></div></div>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">Hotspots API 1.0.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">hotspots.calculation</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright Chris Radoux, Peter Curran, Mihaela D. Smilova, Richard A. Sykes, Alicia Higueruelo, Anthony Bradley, Brian D. Marsdend, David R. Spring, Tom L. Blundell, Andrew R. Leach, William R. Pitt, Jason C. Cole.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>