%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{Fragment Hotspot Maps Documentation}
\date{Apr 07, 2020}
\release{1.0.2}
\author{Contributors: Chris Radoux, Peter Curran, Mihaela D. Smilova, Richard A. Sykes, Alicia Higueruelo, Anthony Bradley, Brian D. Marsdend, David R. Spring, Tom L. Blundell, Andrew R. Leach, William R. Pitt, Jason C. Cole}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


\noindent\sphinxincludegraphics{{hotspots-api-gh-banner}.png}

This API is publicly available, it is dependant on the CSD python API \sphinxhyphen{} a commercial package.
If you are an academic user, it’s likely your institution will have a license. If you are unsure if you have a
license or would like to enquire about purchasing one, please contact \sphinxhref{mailto:support@ccdc.cam.ac.uk}{support@ccdc.cam.ac.uk}

Please note, this is an academic project and we would therefore welcome feedback, contributions and collaborations.
If you have any queries regarding this package please contact us (\sphinxhref{mailto:pcurran@ccdc.cam.ac.uk}{pcurran@ccdc.cam.ac.uk})!

NB: We recommend installing on a Linux machine. If this isn’t possible, be aware that only the LIGSITE method will be
available for the buriedness calculation.


\chapter{Introduction}
\label{\detokenize{tutorial:introduction}}\label{\detokenize{tutorial::doc}}
Fragment hotspot maps predicts the location and key interaction features of small molecule binding “hotspots” and
provides valuable insights for several stages of early drug and drug target discovery. Built upon the vast quantity of
interaction data in the CSD, fragment hotspot maps is able to rapidly detect hotspots from a global search of a
protein.

The probability of forming common intermolecular interactions (hydrogen\sphinxhyphen{}bonding, charged, apolar) is estimated using
Superstar. Superstar fragments a protein and uses interaction libraries, abstracted from the CSD, to predict the
likelihood of finding a probe atom at a given point. The following probes are used: “apolar”: Aromatic CH Carbon,
“acceptor”: Carbonyl oxygen, “donor”: Uncharged NH Nitrogen, “negative”: Carboxylate, “positive”: Charged NH Nitrogen.
Although SuperStar does have some hydrophobic correction, the local protein environment is not fully considered.
Consequently, large regions of the protein are scored highly. Hotspots arise from enclosed,
hydrophobic pockets that can form directional, polar interactions. Therefore, this method incorporates these physical
characteristics into the detection of hotspots. This is done in two ways; weighting the SuperStar Maps by the degree of
burial and sampling the weighted maps using hydrophobic molecular probes. This method was validated on a set of 21
fragment\sphinxhyphen{}to\sphinxhyphen{}lead progression. The median fragment atom scores were in the top 98\% of all grid point scores.


\chapter{Installation Notes}
\label{\detokenize{tutorial:installation-notes}}

\section{1 Install CSDS 2020}
\label{\detokenize{tutorial:install-csds-2020}}
The CSDS is available from {[}here{]}(\sphinxurl{https://www.ccdc.cam.ac.uk/support-and-resources/csdsdownloads/}).

You will need your customer number and activation key. You must activate your license before proceeding.


\section{2 Install GHECOM}
\label{\detokenize{tutorial:install-ghecom}}
Ghecom is available from {[}here{]}(\sphinxurl{https://pdbj.org/ghecom/download\_src.html}).

“The source code of the GHECOM is written in C, and developed and executed on
the linux environment (actually on the Fedora Core).  For the installation,
you need the gcc compiler.  If you do not want to use it, please change the
“Makefile” in the “src” directory.”

Download the file \sphinxcode{\sphinxupquote{ghecom\sphinxhyphen{}src\sphinxhyphen{}{[}date{]}.tar.gz}} file.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
tar zxvf ghecom\PYGZhy{}src\PYGZhy{}\PYG{o}{[}date\PYG{o}{]}.tar.gz
\PYG{n+nb}{cd} src
make
\end{sphinxVerbatim}

NB: The executable will be located at the parent directory.


\section{3 Create conda environment}
\label{\detokenize{tutorial:create-conda-environment}}
Download the environment.yml file from the github repositiory.

Open the file, and edit the file path to the your local ccdc conda channel
that was installed as part of your CSDS. For example: “\sphinxurl{file:///home/pcurran/CCDC/Python\_API\_2020/ccdc\_conda\_channel}”

Save and close environment.yml.

Create conda environment using the environment.yml:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda create \PYGZhy{}n hotspots \PYGZhy{}f environment.yml
\end{sphinxVerbatim}

Finally, there are a few environment variables to set:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{CSDHOME}\PYG{o}{=}/home/my\PYGZus{}ccdc\PYGZus{}software\PYGZus{}dir/CCDC/CSD\PYGZus{}2020
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{LD\PYGZus{}LIBRARY\PYGZus{}PATH}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}CONDA\PYGZus{}PREFIX}/lib:\PYG{n+nv}{\PYGZdl{}CONDA\PYGZus{}PREFIX}/lib/python3.7/site\PYGZhy{}packages/ccdc/\PYGZus{}lib:\PYG{n+nv}{\PYGZdl{}LD\PYGZus{}LIBRARY\PYGZus{}PATH}
\PYGZdl{} \PYG{n+nb}{export} \PYG{n+nv}{GHECOM\PYGZus{}EXE}\PYG{o}{=}\PYG{n+nv}{\PYGZdl{}PREFIX}/ghecom\PYGZus{}latest/ghecom
\end{sphinxVerbatim}

We recommend saving these within your conda environment. To do this, see \sphinxtitleref{setup\_environment.sh} shell script within
the hotspots repositiory. For more details on saving environment variables, see the
conda {[}documentation{]}(\sphinxurl{https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html}).


\section{4 Install Hotspots API}
\label{\detokenize{tutorial:install-hotspots-api}}
Install Hotspots v1.0.3:
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\item {} 
Latest stable release (recommended for most users):

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
conda activate hotspots

pip install hotspots
or
pip install https://github.com/prcurran/hotspots/archive/v1.0.3.zip
\end{sphinxVerbatim}
\begin{enumerate}
\sphinxsetlistlabels{\alph}{enumi}{enumii}{}{)}%
\setcounter{enumi}{1}
\item {} 
Very latest code

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
mkdir ./hotspots\PYGZus{}code
\PYG{n+nb}{cd} hotspots\PYGZus{}code

git clone git@github.com:prcurran/hotspots.git
conda activate hotspots
pip install ./hotspots
\end{sphinxVerbatim}

… and you’re ready to go!


\chapter{Cookbook Documentation}
\label{\detokenize{tutorial:cookbook-documentation}}

\section{Running a Calculation}
\label{\detokenize{tutorial:running-a-calculation}}

\subsection{Protein Preparation}
\label{\detokenize{tutorial:protein-preparation}}
The first step is to make sure your protein is correctly prepared for the calculation. The structures should be
protonated with small molecules and waters removed. Any waters or small molecules left in the structure will be included
in the calculation.

One way to do this is to use the CSD Python API:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{protein} \PYG{k+kn}{import} \PYG{n}{Protein}

\PYG{n}{prot} \PYG{o}{=} \PYG{n}{Protein}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{protein.pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{prot}\PYG{o}{.}\PYG{n}{remove\PYGZus{}all\PYGZus{}waters}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{prot}\PYG{o}{.}\PYG{n}{add\PYGZus{}hydrogens}\PYG{p}{(}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{prot}\PYG{o}{.}\PYG{n}{ligands}\PYG{p}{:}
    \PYG{n}{prot}\PYG{o}{.}\PYG{n}{remove\PYGZus{}ligand}\PYG{p}{(}\PYG{n}{l}\PYG{o}{.}\PYG{n}{identifier}\PYG{p}{)}
\end{sphinxVerbatim}

For best results, manually check proteins before submitting them for calculation.


\subsection{Calculating Fragment Hotspot Maps}
\label{\detokenize{tutorial:calculating-fragment-hotspot-maps}}
Once the protein is prepared, the {\hyperref[\detokenize{calculation_api:hotspots.calculation.Runner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.calculation.Runner}}}}} object can be used to perform the calculation:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}

\PYG{n}{r} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{results} \PYG{o}{=} \PYG{n}{Runner}\PYG{o}{.}\PYG{n}{from\PYGZus{}protein}\PYG{p}{(}\PYG{n}{prot}\PYG{p}{)}
\end{sphinxVerbatim}

Alternatively, for a quick calculation, you can supply a PDB code and we will prepare the protein as described above:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{r} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{results} \PYG{o}{=} \PYG{n}{Runner}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Writing}
\label{\detokenize{tutorial:writing}}
The {\hyperref[\detokenize{hs_io_api:module-hotspots.hs_io}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_io}}}}} module handles the reading and writing of both \sphinxcode{\sphinxupquote{hotspots.calculation.results}}
and \sphinxcode{\sphinxupquote{hotspots.best\_volume.Extractor}} objects. The output \sphinxtitleref{.grd} files can become quite large, but are highly
compressible, therefore the results are written to a \sphinxtitleref{.zip} archive by default, along with a PyMOL run script to
visualise the output.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hotspots} \PYG{k+kn}{import} \PYG{n}{hs\PYGZus{}io}

\PYG{n}{out\PYGZus{}dir} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{results/pdb1}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Creates \PYGZdq{}results/pdb1/out.zip\PYGZdq{}}
\PYG{k}{with} \PYG{n}{HotspotWriter}\PYG{p}{(}\PYG{n}{out\PYGZus{}dir}\PYG{p}{,} \PYG{n}{grid\PYGZus{}extension}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.grd}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{zip\PYGZus{}results}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)} \PYG{k}{as} \PYG{n}{w}\PYG{p}{:}
    \PYG{n}{w}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{results}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Reading}
\label{\detokenize{tutorial:reading}}
If you want to revisit the results of a previous calculation, you can load the \sphinxtitleref{out.zip} archive directly into a
\sphinxcode{\sphinxupquote{hotspots.calculation.results}} instance:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hotspots} \PYG{k+kn}{import} \PYG{n}{hs\PYGZus{}io}

\PYG{n}{results} \PYG{o}{=} \PYG{n}{hs\PYGZus{}io}\PYG{o}{.}\PYG{n}{HotspotReader}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{results/pdb1/out.zip}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Tractability Assessment}
\label{\detokenize{tutorial:tractability-assessment}}
Not all pockets provide a suitable environment for binding drug\sphinxhyphen{}like molecules. Therefore, good predictions
of target tractability can save time and effort in early hit identification. Fragment Hotspot Maps annotates a
set of grids which span the entire volume of pockets within proteins. The grids are scores represent the
likelihood of making a particular intermolecular interaction and therefore they can be used to differientate
between pockets and help researchers select a pocket with the highest chance of being tractable.

This cookbook example provides a very simple workflow to generate a target tractability model.


\subsection{Tractability workflow}
\label{\detokenize{tutorial:tractability-workflow}}
Firstly, the fragment hotspots calculation is performed. This is done by initialising a \sphinxtitleref{hotspots.calculation.Runner}
class object, and generate a \sphinxtitleref{hotspots.result.Result} object, in this case we used the
\sphinxtitleref{hotspots.calculation.Runner.from\_pdb} method which generates a result from a PDB code.

Next, A \sphinxtitleref{hotspots.result.Result} object is returned. Not all the points within the grids
are relevant \sphinxhyphen{} the entire pocket may not be involved in binding. Therefore, a subset of the cavity grid points are
selected. The Best Continous Volume method is used to return a sub\sphinxhyphen{}pocket which corresponds to a user defined volume,
and the algorithm selects a continous area which maximises the total score of the fragment hotspot maps grid points. In
this case an approximate drug\sphinxhyphen{}like volume of 500 A\textasciicircum{}3 is used. This is carried out by using the
\sphinxtitleref{hotspots.Extractor.extract\_volume()} class method.

Finally, the score distribution for the best continuous volume are used to discriminate between different pockets. For
this simple cookbook example, we use the median value to rank the different pockets. These are returned as a dataframe.
The code block below contains the complete workflow:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{result} \PYG{k+kn}{import} \PYG{n}{Extractor}


\PYG{k}{def} \PYG{n+nf}{tractability\PYGZus{}workflow}\PYG{p}{(}\PYG{n}{protein}\PYG{p}{,} \PYG{n}{tag}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    A very simple tractability workflow.}

\PYG{l+s+sd}{    :param str protein: PDB identification code}
\PYG{l+s+sd}{    :param str tag: Tractability tag: either \PYGZsq{}druggable\PYGZsq{} or \PYGZsq{}less\PYGZhy{}druggable\PYGZsq{}}
\PYG{l+s+sd}{    :return: `pandas.DataFrame`}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} 1) calculate Fragment Hotspot Result}
    \PYG{n}{runner} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{result} \PYG{o}{=} \PYG{n}{runner}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{n}{pdb\PYGZus{}code}\PYG{o}{=}\PYG{n}{protein}\PYG{p}{,}
                             \PYG{n}{nprocesses}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
                             \PYG{n}{buriedness\PYGZus{}method}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ghecom}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} 2) calculate Best Continuous Volume}
    \PYG{n}{extractor} \PYG{o}{=} \PYG{n}{Extractor}\PYG{p}{(}\PYG{n}{hr}\PYG{o}{=}\PYG{n}{result}\PYG{p}{)}
    \PYG{n}{bcv\PYGZus{}result} \PYG{o}{=} \PYG{n}{extractor}\PYG{o}{.}\PYG{n}{extract\PYGZus{}volume}\PYG{p}{(}\PYG{n}{volume}\PYG{o}{=}\PYG{l+m+mi}{500}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} 3) find the median score}
    \PYG{k}{for} \PYG{n}{probe}\PYG{p}{,} \PYG{n}{grid} \PYG{o+ow}{in} \PYG{n}{bcv\PYGZus{}result}\PYG{o}{.}\PYG{n}{super\PYGZus{}grids}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{values} \PYG{o}{=} \PYG{n}{grid}\PYG{o}{.}\PYG{n}{grid\PYGZus{}values}\PYG{p}{(}\PYG{n}{threshold}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}
        \PYG{n}{median} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} 4) return the data}
    \PYG{k}{return} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scores}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{values}\PYG{p}{,}
                         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{protein}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}\PYG{p}{,}
                         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{median}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{median}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}\PYG{p}{,}
                         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tractability}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{tag}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}\PYG{p}{,}
                         \PYG{p}{\PYGZcb{}}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Ranking Pockets}
\label{\detokenize{tutorial:ranking-pockets}}
For this tutorial example, we simply rank the pockets by the median value of the best continuous volume score. Of course,
for more complex ranking or classification methods could be used if desired. For this example, we take a random
selection of 65 (43 = ‘druggable’, 22 = ‘less druggable’). More information on this dataset

Krasowski, A.; Muthas, D.; Sarkar, A.; Schmitt, S.; Brenk, R. DrugPred : A Structure\sphinxhyphen{}Based Approach To Predict
Protein Druggability Developed Using an Extensive Nonredundant Data Set.
J. Chem. Inf. Model. 2011, 2829\textendash{}2842. \sphinxurl{https://doi.org/10.1021/ci200266d}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{subset} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1e9x}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1udt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2bxr}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1r9o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{3d4s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1k8q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1xm6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1rwq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1yvf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2hiw}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1gwr}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2g24}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1c14}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1ywn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1hvy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1f9g}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1ai2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2ivu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2dq7}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1m2z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2fb8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1o5r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2gh5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1ke6}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1k7f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1ucn}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1hw8}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2br1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2i0e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1js3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1yqy}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1u4d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1sqi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2gsu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1kvo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1gpu}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1qpe}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1hvr}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1ig3}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1g7v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1qmf}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1r58}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1v4s}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1fth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1rsz}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1n2v}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1m17}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1kts}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1ywr}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2gyi}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1cg0}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{5yas}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1icj}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1gkc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1hqg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1u30}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1nnc}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1c9y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1j4i}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{d}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1qxo}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1o8b}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1nlj}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1rnt}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1d09}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1olq}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{\PYGZcb{}}

    \PYG{n}{pdbs}\PYG{p}{,} \PYG{n}{tags} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{p}{[}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{pdb}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{tag}\PYG{p}{)}\PYG{p}{]} \PYG{k}{for} \PYG{n}{pdb}\PYG{p}{,} \PYG{n}{tag} \PYG{o+ow}{in} \PYG{n}{training\PYGZus{}set}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}

    \PYG{k}{with} \PYG{n}{concurrent}\PYG{o}{.}\PYG{n}{futures}\PYG{o}{.}\PYG{n}{ProcessPoolExecutor}\PYG{p}{(}\PYG{n}{max\PYGZus{}workers}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)} \PYG{k}{as} \PYG{n}{executor}\PYG{p}{:}
        \PYG{n}{dfs} \PYG{o}{=} \PYG{n}{executor}\PYG{o}{.}\PYG{n}{map}\PYG{p}{(}\PYG{n}{tractability\PYGZus{}workflow}\PYG{p}{,} \PYG{n}{pdbs}\PYG{p}{,} \PYG{n}{tags}\PYG{p}{)}

    \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{dfs}\PYG{p}{,} \PYG{n}{ignore\PYGZus{}index}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{sort\PYGZus{}values}\PYG{p}{(}\PYG{n}{by}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{median}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ascending}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

    \PYG{n}{df}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scores.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

We can visualise the score distributions using the seaborn plotting library and use the \sphinxtitleref{ccdc.descriptors} module for
statical analysis on the ranked pockets.


\subsubsection{JoyPlot}
\label{\detokenize{tutorial:joyplot}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} adapted from the seaborn documentation.}
\PYG{c+c1}{\PYGZsh{}}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{patches} \PYG{k}{as} \PYG{n+nn}{patches}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k}{as} \PYG{n+nn}{sns}

\PYG{k}{def} \PYG{n+nf}{joyplot}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{fname}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{test.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Visualises the Fragment Hotspot Maps score distributions as}
\PYG{l+s+sd}{    a series of stacked kernal density estimates ordered by}
\PYG{l+s+sd}{    median value.}

\PYG{l+s+sd}{    Adapted from the seaborn gallery:}
\PYG{l+s+sd}{        https://seaborn.pydata.org/examples/kde\PYGZus{}ridgeplot.html}

\PYG{l+s+sd}{    :param `pandas.DataFrame` df: Fragment Hotspot scores data}
\PYG{l+s+sd}{    :return None}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{sns}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{style}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{white}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
            \PYG{n}{rc}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{axes.facecolor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
            \PYG{n}{font\PYGZus{}scale}\PYG{o}{=}\PYG{l+m+mi}{6}\PYG{p}{)}

    \PYG{n}{palette} \PYG{o}{=} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}c75048}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
               \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}5bd9a4}\PYG{l+s+s2}{\PYGZdq{}}
               \PYG{p}{]}

    \PYG{c+c1}{\PYGZsh{} Initialize the FacetGrid object}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{FacetGrid}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,}
                       \PYG{n}{row}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pdb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{n}{hue}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tractability}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                       \PYG{n}{height}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
                       \PYG{n}{aspect}\PYG{o}{=}\PYG{l+m+mi}{75}\PYG{p}{,}
                       \PYG{n}{palette}\PYG{o}{=}\PYG{n}{palette}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Draw the densities in a few steps}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{map}\PYG{p}{(}\PYG{n}{sns}\PYG{o}{.}\PYG{n}{kdeplot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scores}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{clip\PYGZus{}on}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{shade}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{alpha}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{7}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{bw}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{map}\PYG{p}{(}\PYG{n}{sns}\PYG{o}{.}\PYG{n}{kdeplot}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{scores}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{clip\PYGZus{}on}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{w}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{lw}\PYG{o}{=}\PYG{l+m+mi}{9}\PYG{p}{,} \PYG{n}{bw}\PYG{o}{=}\PYG{o}{.}\PYG{l+m+mi}{2}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Format the plots}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{xlim}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{25}\PYG{p}{)}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{}}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{fig}\PYG{o}{.}\PYG{n}{subplots\PYGZus{}adjust}\PYG{p}{(}\PYG{n}{hspace}\PYG{o}{=}\PYG{o}{\PYGZhy{}}\PYG{o}{.}\PYG{l+m+mi}{9}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}titles}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{yticks}\PYG{o}{=}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{despine}\PYG{p}{(}\PYG{n}{bottom}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{left}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Create legend, and position}
    \PYG{n}{tag} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Druggable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Less\PYGZhy{}Druggable}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}
    \PYG{n}{labels} \PYG{o}{=} \PYG{p}{[}\PYG{n}{tag}\PYG{p}{[}\PYG{n}{s}\PYG{p}{]} \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tractability}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{handles} \PYG{o}{=} \PYG{p}{[}\PYG{n}{patches}\PYG{o}{.}\PYG{n}{Patch}\PYG{p}{(}\PYG{n}{color}\PYG{o}{=}\PYG{n}{col}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{lab}\PYG{p}{)}
               \PYG{k}{for} \PYG{n}{col}\PYG{p}{,} \PYG{n}{lab} \PYG{o+ow}{in} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{n}{palette}\PYG{p}{,} \PYG{n}{labels}\PYG{p}{)}\PYG{p}{]}

    \PYG{n}{legend} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{handles}\PYG{o}{=}\PYG{n}{handles}\PYG{p}{,}
                        \PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Tractability}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                        \PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{upper right}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                        \PYG{n}{bbox\PYGZus{}to\PYGZus{}anchor}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mf}{0.3}\PYG{p}{,} \PYG{l+m+mf}{7.5}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{frame} \PYG{o}{=} \PYG{n}{legend}\PYG{o}{.}\PYG{n}{get\PYGZus{}frame}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{frame}\PYG{o}{.}\PYG{n}{set\PYGZus{}facecolor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{frame}\PYG{o}{.}\PYG{n}{set\PYGZus{}edgecolor}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scores.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{df} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{sort\PYGZus{}values}\PYG{p}{(}\PYG{n}{by}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{median}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ascending}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{joyplot}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{druggable\PYGZus{}joy.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{druggable_joy}.png}


\subsubsection{Rank Statistics}
\label{\detokenize{tutorial:rank-statistics}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{operator}
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k}{as} \PYG{n+nn}{sns}

\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{descriptors} \PYG{k+kn}{import} \PYG{n}{StatisticalDescriptors} \PYG{k}{as} \PYG{n}{sd}


\PYG{k}{def} \PYG{n+nf}{rocplot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{fname}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{roc.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Create a ROC Curve using seaborn}

\PYG{l+s+sd}{    :param lists data: supply ranked data as list of list}
\PYG{l+s+sd}{    :return: None}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{rs} \PYG{o}{=} \PYG{n}{sd}\PYG{o}{.}\PYG{n}{RankStatistics}\PYG{p}{(}\PYG{n}{scores}\PYG{o}{=}\PYG{n}{data}\PYG{p}{,} \PYG{n}{activity\PYGZus{}column}\PYG{o}{=}\PYG{n}{operator}\PYG{o}{.}\PYG{n}{itemgetter}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{tpr}\PYG{p}{,} \PYG{n}{fpr} \PYG{o}{=} \PYG{n}{rs}\PYG{o}{.}\PYG{n}{ROC}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{lineplot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{n}{fpr}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{n}{tpr}\PYG{p}{,} \PYG{n}{estimator}\PYG{o}{=}\PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsh{}c75048}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax} \PYG{o}{=} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{lineplot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{grey}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{n}{xlabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{FPR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ylabel}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TPR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{title}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ROC Curve (AUC: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{AUC}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{.2f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{read\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{scores.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{t} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{m} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
\PYG{n}{letter\PYGZus{}to\PYGZus{}number} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{d}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+m+mi}{0}\PYG{p}{\PYGZcb{}}
\PYG{k}{for} \PYG{n}{p} \PYG{o+ow}{in} \PYG{n+nb}{set}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{a} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{pdb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{p}\PYG{p}{]}
    \PYG{n}{t}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n}{letter\PYGZus{}to\PYGZus{}number}\PYG{p}{[}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tractability}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{m}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{a}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{median}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}

\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{tractability}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{t}\PYG{p}{,}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{median}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{n}{m}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
\PYG{n}{df} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{sort\PYGZus{}values}\PYG{p}{(}\PYG{n}{by}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{median}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{ascending}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\PYG{n}{data} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{median}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tractability}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}

\PYG{n}{rocplot}\PYG{p}{(}\PYG{n}{data}\PYG{p}{,} \PYG{n}{fname}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{druggable\PYGZus{}roc.png}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{druggable_roc}.png}


\section{Hotspot\sphinxhyphen{}Guided Docking}
\label{\detokenize{tutorial:hotspot-guided-docking}}
Molecular docking is a staple of early\sphinxhyphen{}stage hit identification. When active small molecules are known,
key interactions can be selected to steer the scoring of molecular pose to favour those molecules making the selected
interaction. Fragment Hotspot maps can predict critical interactions in the absence of binding data. Using these
predictions as constraints will likely improve docking enrichment. A preliminary study was conducted by (Radoux, 2018)
and a full validation is currently underway. Protein Kinase B (AKT1) has been chosen for this tutorial example and was
used in the prelimenary docking study.

Radoux, C. J. The Automatic Detection of Small Molecule Binding Hotspots on Proteins Applying Hotspots
to Structure\sphinxhyphen{}Based Drug Design. (2018). doi:10.17863/CAM.22314


\subsection{A Hotspot Constraint}
\label{\detokenize{tutorial:a-hotspot-constraint}}
To begin, a hotspot calculation is performed on AKT1 (PDB: 3cqw). For this example, the protein was
protonated using X, all waters, ligands and metal centres were removed.

\sphinxtitleref{hotspots.hsdocking.DockerSettings} inherits from \sphinxtitleref{ccdc.docking.Docker.Settings} to allow smooth integration with the
CCDC python API. The following code snippet demonstrates how a constraint is generated and added to the
\sphinxtitleref{hotspots.hsdocking.DockerSettings} class.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}docking} \PYG{k+kn}{import} \PYG{n}{DockerSettings}
\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}io} \PYG{k+kn}{import} \PYG{n}{HotspotReader}


\PYG{n}{result} \PYG{o}{=} \PYG{n}{HotspotReader}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{pathtohotspot}\PYG{o}{\PYGZgt{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{docker} \PYG{o}{=} \PYG{n}{Docker}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings} \PYG{o}{=} \PYG{n}{DockerSettings}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}protein\PYGZus{}file}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{pathtoprotein}\PYG{o}{\PYGZgt{}}\PYG{p}{)}

\PYG{n}{constraints} \PYG{o}{=}
\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{HotspotHBondConstraint}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{protein}\PYG{o}{=}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{proteins}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                                            \PYG{n}{hr}\PYG{o}{=}\PYG{n}{result}\PYG{p}{,}
                                                            \PYG{n}{weight}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{,}
                                                            \PYG{n}{min\PYGZus{}hbond\PYGZus{}score}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,}
                                                            \PYG{n}{max\PYGZus{}constraints}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{constraint} \PYG{o+ow}{in} \PYG{n}{constraints}\PYG{p}{:}
    \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}constraint}\PYG{p}{(}\PYG{n}{constraint}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{View the Constraints}
\label{\detokenize{tutorial:view-the-constraints}}
The automatic hotspot constraints are designed to be used unsupervised, as part of large scale docking studies where
it is not practical to assess every protein manually. However, if you are studying a small number of proteins, you
may want to view the suggested hydrogen bond constraints before running GOLD docking.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{hotspot} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}path to hotspot out.zip\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{hotspot} \PYG{o}{=} \PYG{n}{HotspotReader}\PYG{p}{(}\PYG{n}{hotspot}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{for} \PYG{n}{p}\PYG{p}{,} \PYG{n}{g} \PYG{o+ow}{in} \PYG{n}{hotspot}\PYG{o}{.}\PYG{n}{super\PYGZus{}grids}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{hotspot}\PYG{o}{.}\PYG{n}{super\PYGZus{}grids}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{max\PYGZus{}value\PYGZus{}of\PYGZus{}neighbours}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} grayscale dilation used for noise reduction}

\PYG{n}{constraints} \PYG{o}{=} \PYG{n}{hotspot}\PYG{o}{.}\PYG{n}{\PYGZus{}docking\PYGZus{}constraint\PYGZus{}atoms}\PYG{p}{(}\PYG{n}{max\PYGZus{}constraints}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{,}
                                                \PYG{n}{max\PYGZus{}distance}\PYG{o}{=}\PYG{l+m+mi}{4}\PYG{p}{,}
                                                \PYG{n}{threshold}\PYG{o}{=}\PYG{l+m+mi}{17}\PYG{p}{,}
                                                \PYG{n}{min\PYGZus{}size}\PYG{o}{=}\PYG{l+m+mi}{8}
                                                \PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} max\PYGZus{}constraints: limits the number of constraints selected}
\PYG{c+c1}{\PYGZsh{} max\PYGZus{}distance: island cenrtroid must be within max\PYGZus{}distance to be selected}
\PYG{c+c1}{\PYGZsh{} threshold: hotspots contoured a threshold score}
\PYG{c+c1}{\PYGZsh{} min\PYGZus{}size: island must have \PYGZgt{} min\PYGZus{}size grid points to be selected}

\PYG{n}{mol} \PYG{o}{=} \PYG{n}{constraints}\PYG{o}{.}\PYG{n}{to\PYGZus{}molecule}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{with} \PYG{n}{MoleculeWriter}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{constraints.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{w}\PYG{p}{:}
    \PYG{n}{w}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{mol}\PYG{p}{)}
\end{sphinxVerbatim}

The docking constraints generated from the hotspots can be converted into a \sphinxtitleref{ccdc.molecule.Molecule} object and then
easily visualised in a molecular visualing program. We use PyMOL. In this case, 1 hydrogen bond donor constraint is
selected and therefore there is no selection to be made.

\noindent\sphinxincludegraphics{{constraints}.png}


\subsection{GOLD Docking}
\label{\detokenize{tutorial:gold-docking}}
With the modified docking settings class, the rest of the docking calculation is carried out in a similar manner to
any other GOLD API docking. A full run script is provided below, which has been adapted from the CCDC API
documentation.

\sphinxurl{https://downloads.ccdc.cam.ac.uk/documentation/API/cookbook\_examples/docking\_examples.html}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{dock}\PYG{p}{(}\PYG{n}{inputs}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    submit a GOLD API docking calculation using}
\PYG{l+s+sd}{    docking constraints automatically generated}
\PYG{l+s+sd}{    from the Hotspot API}

\PYG{l+s+sd}{    :param ligand\PYGZus{}path:}
\PYG{l+s+sd}{    :param out\PYGZus{}path:}
\PYG{l+s+sd}{    :param hotspot:}
\PYG{l+s+sd}{    :param weight:}
\PYG{l+s+sd}{    :return:}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}ligands}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{ligand\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}

        \PYG{k}{with} \PYG{n}{gzip}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ligand\PYGZus{}path}\PYG{p}{,}
                                    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{actives\PYGZus{}final.mol2.gz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f\PYGZus{}in}\PYG{p}{:}

            \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{,}
                                    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{actives\PYGZus{}final.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f\PYGZus{}out}\PYG{p}{:}
                \PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copyfileobj}\PYG{p}{(}\PYG{n}{f\PYGZus{}in}\PYG{p}{,} \PYG{n}{f\PYGZus{}out}\PYG{p}{)}

        \PYG{k}{with} \PYG{n}{gzip}\PYG{o}{.}\PYG{n}{open}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ligand\PYGZus{}path}\PYG{p}{,}
                                    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{decoys\PYGZus{}final.mol2.gz}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f\PYGZus{}in}\PYG{p}{:}
            \PYG{k}{with} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{,}
                                   \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{decoys\PYGZus{}final.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wb}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{f\PYGZus{}out}\PYG{p}{:}
                \PYG{n}{shutil}\PYG{o}{.}\PYG{n}{copyfileobj}\PYG{p}{(}\PYG{n}{f\PYGZus{}in}\PYG{p}{,} \PYG{n}{f\PYGZus{}out}\PYG{p}{)}

        \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}ligand\PYGZus{}file}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{,}
                                                     \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{actives\PYGZus{}final.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                                        \PYG{n}{ndocks}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}

        \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}ligand\PYGZus{}file}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{output\PYGZus{}directory}\PYG{p}{,}
                                                     \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{decoys\PYGZus{}final.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                                        \PYG{n}{ndocks}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}protein}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{hotspot}\PYG{p}{,} \PYG{n}{junk}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{pfile} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{junk}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{protein.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{k}{with} \PYG{n}{MoleculeWriter}\PYG{p}{(}\PYG{n}{pfile}\PYG{p}{)} \PYG{k}{as} \PYG{n}{w}\PYG{p}{:}
            \PYG{n}{w}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{hotspot}\PYG{o}{.}\PYG{n}{protein}\PYG{p}{)}

        \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}protein\PYGZus{}file}\PYG{p}{(}\PYG{n}{pfile}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{define\PYGZus{}binding\PYGZus{}site}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{ligand\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{crystal\PYGZus{}ligand} \PYG{o}{=} \PYG{n}{MoleculeReader}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{ligand\PYGZus{}path}\PYG{p}{,}
                                                     \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{crystal\PYGZus{}ligand.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
                                         \PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
        \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{binding\PYGZus{}site} \PYG{o}{=}
        \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{BindingSiteFromLigand}\PYG{p}{(}\PYG{n}{protein}\PYG{o}{=}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{proteins}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                              \PYG{n}{ligand}\PYG{o}{=}\PYG{n}{crystal\PYGZus{}ligand}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{add\PYGZus{}hotspot\PYGZus{}constraint}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{hotspot}\PYG{p}{,} \PYG{n}{weight}\PYG{p}{)}\PYG{p}{:}

        \PYG{k}{if} \PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{)} \PYG{o}{!=} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n}{constraints} \PYG{o}{=}
            \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{HotspotHBondConstraint}\PYG{o}{.}\PYG{n}{create}\PYG{p}{(}\PYG{n}{protein}\PYG{o}{=}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{proteins}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}
                                                          \PYG{n}{hr}\PYG{o}{=}\PYG{n}{hotspot}\PYG{p}{,}
                                                          \PYG{n}{weight}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{weight}\PYG{p}{)}\PYG{p}{,}
                                                          \PYG{n}{min\PYGZus{}hbond\PYGZus{}score}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{,}
                                                          \PYG{n}{max\PYGZus{}constraints}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}

            \PYG{k}{for} \PYG{n}{constraint} \PYG{o+ow}{in} \PYG{n}{constraints}\PYG{p}{:}
                \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}constraint}\PYG{p}{(}\PYG{n}{constraint}\PYG{p}{)}

    \PYG{k}{def} \PYG{n+nf}{write}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{out\PYGZus{}path}\PYG{p}{)}\PYG{p}{:}

        \PYG{n}{results} \PYG{o}{=} \PYG{n}{Docker}\PYG{o}{.}\PYG{n}{Results}\PYG{p}{(}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} write ligands}
        \PYG{k}{with} \PYG{n}{MoleculeWriter}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{out\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{docked\PYGZus{}ligand.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)} \PYG{k}{as} \PYG{n}{w}\PYG{p}{:}
            \PYG{k}{for} \PYG{n}{d} \PYG{o+ow}{in} \PYG{n}{results}\PYG{o}{.}\PYG{n}{ligands}\PYG{p}{:}
                \PYG{n}{w}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{d}\PYG{o}{.}\PYG{n}{molecule}\PYG{p}{)}

        \PYG{c+c1}{\PYGZsh{} copy ranking file}
        \PYG{c+c1}{\PYGZsh{}}
        \PYG{c+c1}{\PYGZsh{} in this example, this is the only file we use for analysis.}
        \PYG{c+c1}{\PYGZsh{} However, other output files can be useful.}

        \PYG{n}{copyfile}\PYG{p}{(}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{junk}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bestranking.lst}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,}
                 \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{out\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bestranking.lst}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} GOLD docking routine}
    \PYG{n}{ligand\PYGZus{}path}\PYG{p}{,} \PYG{n}{out\PYGZus{}path}\PYG{p}{,} \PYG{n}{hotspot}\PYG{p}{,} \PYG{n}{weight}\PYG{p}{,} \PYG{n}{search\PYGZus{}efficiency} \PYG{o}{=} \PYG{n}{inputs}
    \PYG{n}{docker} \PYG{o}{=} \PYG{n}{Docker}\PYG{p}{(}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} GOLD settings}
    \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings} \PYG{o}{=} \PYG{n}{DockerSettings}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{fitness\PYGZus{}function} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{plp}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{autoscale} \PYG{o}{=} \PYG{n}{search\PYGZus{}efficiency}
    \PYG{n}{junk}\PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{out\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{all}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{junk}

    \PYG{c+c1}{\PYGZsh{} GOLD write lots of files we don\PYGZsq{}t need in this example}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{junk}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{junk}\PYG{p}{)}
    \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{output\PYGZus{}file} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{junk}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{docked\PYGZus{}ligands.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} read the hotspot}
    \PYG{n}{hotspot} \PYG{o}{=} \PYG{n}{HotspotReader}\PYG{p}{(}\PYG{n}{hotspot}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{for} \PYG{n}{p}\PYG{p}{,} \PYG{n}{g} \PYG{o+ow}{in} \PYG{n}{hotspot}\PYG{o}{.}\PYG{n}{super\PYGZus{}grids}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{hotspot}\PYG{o}{.}\PYG{n}{super\PYGZus{}grids}\PYG{p}{[}\PYG{n}{p}\PYG{p}{]} \PYG{o}{=} \PYG{n}{g}\PYG{o}{.}\PYG{n}{max\PYGZus{}value\PYGZus{}of\PYGZus{}neighbours}\PYG{p}{(}\PYG{p}{)}
        \PYG{c+c1}{\PYGZsh{} dilation to reduce noise}

    \PYG{n}{add\PYGZus{}ligands}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,}\PYG{n}{ligand\PYGZus{}path}\PYG{p}{)}
    \PYG{n}{add\PYGZus{}protein}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{hotspot}\PYG{p}{,} \PYG{n}{junk}\PYG{p}{)}
    \PYG{n}{define\PYGZus{}binding\PYGZus{}site}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{ligand\PYGZus{}path}\PYG{p}{)}
    \PYG{n}{add\PYGZus{}hotspot\PYGZus{}constraint}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{hotspot}\PYG{p}{,} \PYG{n}{weight}\PYG{p}{)}

    \PYG{n}{docker}\PYG{o}{.}\PYG{n}{dock}\PYG{p}{(}\PYG{n}{file\PYGZus{}name}\PYG{o}{=}\PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{out\PYGZus{}path}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{hs\PYGZus{}gold.conf}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{write}\PYG{p}{(}\PYG{n}{docker}\PYG{p}{,} \PYG{n}{out\PYGZus{}path}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Clean out unwanted files}
    \PYG{n}{shutil}\PYG{o}{.}\PYG{n}{rmtree}\PYG{p}{(}\PYG{n}{junk}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{create\PYGZus{}dir}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{if} \PYG{o+ow}{not} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{exists}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{os}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{path}


\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}

    \PYG{n}{ligand\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}path to input directory\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{output\PYGZus{}path} \PYG{o}{=}  \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}path to output directory\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{hotspot\PYGZus{}path} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}path to out.zip\PYGZgt{}}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{n}{constraint\PYGZus{}weight} \PYG{o}{=} \PYG{l+m+mi}{10}
    \PYG{n}{search\PYGZus{}efficiency} \PYG{o}{=} \PYG{l+m+mi}{100}

    \PYG{n}{dock}\PYG{p}{(}\PYG{n}{inputs}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ligand\PYGZus{}path}\PYG{p}{,}
                 \PYG{n}{output\PYGZus{}path}\PYG{p}{,}
                 \PYG{n}{hotspot\PYGZus{}path}\PYG{p}{,}
                 \PYG{n}{constraint\PYGZus{}weight}\PYG{p}{,}
                 \PYG{n}{search\PYGZus{}efficiency}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}


\subsection{Performance Demonstration}
\label{\detokenize{tutorial:performance-demonstration}}
Using the code above, the AKT1 DUD\sphinxhyphen{}e set was docked against AKT1 (PDB: 3cqw), using the hotspot selected constraint
(the amide hydrogen of ALA230). The docking calculations were run varying the weight of the protein hydrogen bond
constraint {[}0, 10, 100{]} and the search efficiency {[}1, 10, 100{]}.

The most significant effect is on retrieval speed. GOLD can be run using different search efficiencies which control
the degree of sampling in the genetic algorithm.  By using automated constraints, one can outperform 100\%
search efficiency results in 1\% search efficiency settings; a speed improvement of more than an order of magnitude.
While this work showcases this use case, we will undertake further work in future to evaluate the benefit
more generally across a wider range of targets.

The code to generate the figure and statistics is given below.

\noindent\sphinxincludegraphics{{GOLD_results}.png}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{os}

\PYG{k+kn}{import} \PYG{n+nn}{numpy} \PYG{k}{as} \PYG{n+nn}{np}
\PYG{k+kn}{import} \PYG{n+nn}{operator}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{k+kn}{import} \PYG{n+nn}{seaborn} \PYG{k}{as} \PYG{n+nn}{sns}
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt}
\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{descriptors} \PYG{k+kn}{import} \PYG{n}{StatisticalDescriptors} \PYG{k}{as} \PYG{n}{sd}

\PYG{k}{def} \PYG{n+nf}{rank\PYGZus{}stats}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Create two `pandas.DataFrame` from the \PYGZdq{}bestranking.lst\PYGZdq{}}
\PYG{l+s+sd}{    GOLD output}

\PYG{l+s+sd}{    :param str parent: path to parent directory}
\PYG{l+s+sd}{    :param str s: name of subdirectory}
\PYG{l+s+sd}{    :param str w: name of subsubdirectory}
\PYG{l+s+sd}{    :return:}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} read data and process data from output file}
    \PYG{n}{fname} \PYG{o}{=} \PYG{n}{os}\PYG{o}{.}\PYG{n}{path}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{,}
                         \PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{search\PYGZus{}efficiency\PYGZus{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{s}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                         \PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{,}
                         \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{bestranking.lst}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{lines} \PYG{o}{=} \PYG{p}{[}\PYG{n}{l}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n+nb}{open}\PYG{p}{(}\PYG{n}{fname}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{readlines}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}
    \PYG{n}{header} \PYG{o}{=} \PYG{n}{lines}\PYG{p}{[}\PYG{l+m+mi}{5}\PYG{p}{]}
    \PYG{n}{header} \PYG{o}{=} \PYG{p}{[}\PYG{n}{b}\PYG{o}{.}\PYG{n}{strip}\PYG{p}{(}\PYG{p}{)} \PYG{k}{for} \PYG{n}{b} \PYG{o+ow}{in}
              \PYG{p}{[}\PYG{n}{a} \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{header}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{  }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{a} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{and} \PYG{n}{a} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
    \PYG{n+nb}{all} \PYG{o}{=} \PYG{n}{lines}\PYG{p}{[}\PYG{l+m+mi}{7}\PYG{p}{:}\PYG{p}{]}

    \PYG{n}{cat} \PYG{o}{=} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{p}{[}\PYG{p}{[}\PYG{n}{a} \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{entry}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{if} \PYG{n}{a} \PYG{o}{!=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
                     \PYG{k}{for} \PYG{n}{entry} \PYG{o+ow}{in} \PYG{n+nb}{all}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} generate a dataframe and alter datatypes}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{n}{h}\PYG{p}{:} \PYG{n}{cat}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]} \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{h} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{header}\PYG{p}{)}\PYG{p}{\PYGZcb{}}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{actives}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}
        \PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{map}\PYG{p}{(}\PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CHEMBL}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{x}\PYG{p}{,} \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Ligand name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
    \PYG{p}{)}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{int}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{search\PYGZus{}efficiency}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight\PYGZus{}int}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight\PYGZus{}str}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{n}{w}\PYG{p}{)}\PYG{p}{]} \PYG{o}{*} \PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{df}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Score}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Score}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{astype}\PYG{p}{(}\PYG{n+nb}{float}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{log\PYGZus{}time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{np}\PYG{o}{.}\PYG{n}{log10}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Score}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{log\PYGZus{}time}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{actives}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{search\PYGZus{}efficiency}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weight\PYGZus{}int}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
             \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{weight\PYGZus{}str}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
    \PYG{n}{df} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{sort\PYGZus{}values}\PYG{p}{(}\PYG{n}{by}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Score}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ascending}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Use CCDC\PYGZsq{}s descriptors API}
    \PYG{n}{rs} \PYG{o}{=} \PYG{n}{sd}\PYG{o}{.}\PYG{n}{RankStatistics}\PYG{p}{(}\PYG{n}{scores}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n+nb}{zip}\PYG{p}{(}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Score}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
                                           \PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{actives}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}\PYG{p}{,}
                           \PYG{n}{activity\PYGZus{}column}\PYG{o}{=}\PYG{n}{operator}\PYG{o}{.}\PYG{n}{itemgetter}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} ROC}
    \PYG{n}{tpr}\PYG{p}{,} \PYG{n}{fpr} \PYG{o}{=} \PYG{n}{rs}\PYG{o}{.}\PYG{n}{ROC}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{tpr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{tpr}
    \PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fpr}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]} \PYG{o}{=} \PYG{n}{fpr}

    \PYG{c+c1}{\PYGZsh{} Enrichment Metrics}
    \PYG{n}{metric\PYGZus{}df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{search efficiency}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{s}\PYG{p}{]}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{w}\PYG{p}{]}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{AUC}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{AUC}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EF1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{EF}\PYG{p}{(}\PYG{n}{fraction}\PYG{o}{=}\PYG{l+m+mf}{0.01}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EF5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{EF}\PYG{p}{(}\PYG{n}{fraction}\PYG{o}{=}\PYG{l+m+mf}{0.05}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{EF10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{EF}\PYG{p}{(}\PYG{n}{fraction}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BEDROC16}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{BEDROC}\PYG{p}{(}\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mf}{16.1}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}
                             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{BEDROC8}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{[}\PYG{n}{rs}\PYG{o}{.}\PYG{n}{BEDROC}\PYG{p}{(}\PYG{n}{alpha}\PYG{o}{=}\PYG{l+m+mi}{8}\PYG{p}{)}\PYG{p}{]}
                             \PYG{p}{\PYGZcb{}}\PYG{p}{)}
    \PYG{k}{return} \PYG{n}{df}\PYG{p}{,} \PYG{n}{metric\PYGZus{}df}


\PYG{k}{def} \PYG{n+nf}{roc\PYGZus{}plot}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{search\PYGZus{}efficiency}\PYG{p}{,} \PYG{n}{ax}\PYG{p}{,} \PYG{n}{palette}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Set2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Plot a ROC plot for the docking data}

\PYG{l+s+sd}{    :param `pands.DataFrame` df: data}
\PYG{l+s+sd}{    :param int search\PYGZus{}efficiency: data is split by search efficiency}
\PYG{l+s+sd}{    :param `matplotlib.axes.Axes` ax: Matplotlib axis to plot data onto}
\PYG{l+s+sd}{    :param list palette: list of RGB tuples}
\PYG{l+s+sd}{    :return:}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{selected} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{search\PYGZus{}efficiency}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{search\PYGZus{}efficiency}\PYG{p}{]}
    \PYG{c+c1}{\PYGZsh{} random}
    \PYG{n}{sns}\PYG{o}{.}\PYG{n}{lineplot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,} \PYG{n}{color}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{grey}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ax}\PYG{o}{=}\PYG{n}{ax}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} docking rank}

    \PYG{n}{d} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{color}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{color\PYGZus{}palette}\PYG{p}{(}\PYG{n}{palette}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linestyle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{10}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{color}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{color\PYGZus{}palette}\PYG{p}{(}\PYG{n}{palette}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}  \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linestyle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
         \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{100}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{color}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{sns}\PYG{o}{.}\PYG{n}{color\PYGZus{}palette}\PYG{p}{(}\PYG{n}{palette}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{linestyle}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZhy{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}

    \PYG{n}{lines} \PYG{o}{=} \PYG{p}{[}\PYG{n}{ax}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{grp}\PYG{o}{.}\PYG{n}{fpr}\PYG{p}{,} \PYG{n}{grp}\PYG{o}{.}\PYG{n}{tpr}\PYG{p}{,} \PYG{n}{label}\PYG{o}{=}\PYG{n}{n}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{d}\PYG{p}{[}\PYG{n}{n}\PYG{p}{]}\PYG{p}{)}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
             \PYG{k}{for} \PYG{n}{n}\PYG{p}{,} \PYG{n}{grp} \PYG{o+ow}{in} \PYG{n}{selected}\PYG{o}{.}\PYG{n}{groupby}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight\PYGZus{}str}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{]}


    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}title}\PYG{p}{(}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Search Efficiency = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{search\PYGZus{}efficiency}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
                 \PYG{n}{fontdict}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{fontsize}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{\PYGZcb{}}\PYG{p}{)}

    \PYG{k}{return} \PYG{n}{lines}


\PYG{k}{def} \PYG{n+nf}{box\PYGZus{}plot}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,} \PYG{n}{search\PYGZus{}efficiency}\PYG{p}{,} \PYG{n}{ax}\PYG{p}{,} \PYG{n}{palette}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Set2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Plot a boxplot for the docking time data}

\PYG{l+s+sd}{    :param `pands.DataFrame` df: data}
\PYG{l+s+sd}{    :param int search\PYGZus{}efficiency: data is split by search efficiency}
\PYG{l+s+sd}{    :param `matplotlib.axes.Axes` ax: Matplotlib axis to plot data onto}
\PYG{l+s+sd}{    :param list palette: list of RGB tuples}
\PYG{l+s+sd}{    :return:}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}

    \PYG{n}{selected} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{search\PYGZus{}efficiency}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{==} \PYG{n}{search\PYGZus{}efficiency}\PYG{p}{]}
    \PYG{n}{sns}\PYG{o}{.}\PYG{n}{boxplot}\PYG{p}{(}\PYG{n}{x}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{weight\PYGZus{}int}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{y}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{log\PYGZus{}time}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{order}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{,}\PYG{n}{data}\PYG{o}{=}\PYG{n}{selected}\PYG{p}{,}
                \PYG{n}{palette}\PYG{o}{=}\PYG{n}{palette}\PYG{p}{,}\PYG{n}{linewidth}\PYG{o}{=}\PYG{l+m+mf}{1.2}\PYG{p}{,} \PYG{n}{fliersize}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{n}{ax}\PYG{o}{=}\PYG{n}{ax}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{ax}\PYG{o}{.}\PYG{n}{set\PYGZus{}xticks}\PYG{p}{(}\PYG{p}{[}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} just for asthetics}
    \PYG{k}{for} \PYG{n}{patch} \PYG{o+ow}{in} \PYG{n}{ax}\PYG{o}{.}\PYG{n}{artists}\PYG{p}{:}
        \PYG{n}{r}\PYG{p}{,}\PYG{n}{g}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{n}{a} \PYG{o}{=} \PYG{n}{patch}\PYG{o}{.}\PYG{n}{get\PYGZus{}edgecolor}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{patch}\PYG{o}{.}\PYG{n}{set\PYGZus{}edgecolor}\PYG{p}{(}\PYG{p}{(}\PYG{n}{r}\PYG{p}{,}\PYG{n}{g}\PYG{p}{,}\PYG{n}{b}\PYG{p}{,}\PYG{o}{.}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}


\PYG{k}{def} \PYG{n+nf}{\PYGZus{}asthetics}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs}\PYG{p}{,} \PYG{n}{lines}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+sd}{    Extra formatting tasks}

\PYG{l+s+sd}{    :param `matplotlib.figure.Figure` fig: mpl figure}
\PYG{l+s+sd}{    :param list axs: list of  `matplotlib.axes.Axes`}
\PYG{l+s+sd}{    :param `matplotlib.lines.Line2D` lines: ROC lines}
\PYG{l+s+sd}{    :return:}
\PYG{l+s+sd}{    \PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{c+c1}{\PYGZsh{} format axes}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mf}{0.5}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{yticks} \PYG{o}{=} \PYG{p}{[}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{]}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticks}\PYG{p}{(}\PYG{n}{yticks}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}yticklabels}\PYG{p}{(}\PYG{p}{[}\PYG{n+nb}{str}\PYG{p}{(}\PYG{l+m+mi}{10} \PYG{o}{*}\PYG{o}{*} \PYG{n+nb}{float}\PYG{p}{(}\PYG{n}{l}\PYG{p}{)}\PYG{p}{)} \PYG{k}{for} \PYG{n}{l} \PYG{o+ow}{in} \PYG{n}{yticks}\PYG{p}{]}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}xlabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{FPR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{TPR}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{set\PYGZus{}ylabel}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Time per Molecule (s)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} format legend}
    \PYG{n}{fig}\PYG{o}{.}\PYG{n}{legend}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{,}
               \PYG{p}{[}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{w}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}} \PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{p}{]}\PYG{p}{,}
               \PYG{p}{(}\PYG{o}{.}\PYG{l+m+mi}{83}\PYG{p}{,} \PYG{o}{.}\PYG{l+m+mi}{42}\PYG{p}{)}\PYG{p}{,}
               \PYG{n}{title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Constraint Weight}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{} format canvas}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots\PYGZus{}adjust}\PYG{p}{(}\PYG{n}{left}\PYG{o}{=}\PYG{l+m+mf}{0.1}\PYG{p}{,} \PYG{n}{right}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{,} \PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{0.86}\PYG{p}{)}

\PYG{k}{def} \PYG{n+nf}{main}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} read and format the data}
    \PYG{n}{search\PYGZus{}effiencies} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}
    \PYG{n}{weights} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{10}\PYG{p}{,} \PYG{l+m+mi}{100}\PYG{p}{]}
    \PYG{n}{parent} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{/vagrant/github\PYGZus{}pkgs/hotspots/examples/}\PYG{l+s+s2}{\PYGZdq{}} \PYGZbs{}
             \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2\PYGZus{}docking/virtual\PYGZus{}screening/akt1/}\PYG{l+s+s2}{\PYGZdq{}}

    \PYG{n}{df1}\PYG{p}{,} \PYG{n}{df2} \PYG{o}{=} \PYG{n+nb}{zip}\PYG{p}{(}\PYG{o}{*}\PYG{p}{[}\PYG{n}{rank\PYGZus{}stats}\PYG{p}{(}\PYG{n}{parent}\PYG{p}{,} \PYG{n}{s}\PYG{p}{,} \PYG{n}{w}\PYG{p}{)}
                     \PYG{k}{for} \PYG{n}{s} \PYG{o+ow}{in} \PYG{n}{search\PYGZus{}effiencies} \PYG{k}{for} \PYG{n}{w} \PYG{o+ow}{in} \PYG{n}{weights}\PYG{p}{]}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Plotted Data (ROC and Box plots)}
    \PYG{n}{df1} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{df1}\PYG{p}{,} \PYG{n}{ignore\PYGZus{}index}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Table Data (Rank Stats: AUC, EF, BEDROC)}
    \PYG{n}{df2} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{concat}\PYG{p}{(}\PYG{n}{df2}\PYG{p}{,} \PYG{n}{ignore\PYGZus{}index}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}
    \PYG{n}{df2}\PYG{o}{.}\PYG{n}{to\PYGZus{}csv}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{rankstats.csv}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

    \PYG{c+c1}{\PYGZsh{} Plot the ROC and box plots}
    \PYG{n}{sns}\PYG{o}{.}\PYG{n}{set\PYGZus{}style}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{white}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs} \PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{n}{nrows}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{,}
                            \PYG{n}{ncols}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}
                            \PYG{n}{sharey}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{row}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}
                            \PYG{n}{gridspec\PYGZus{}kw}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{wspace}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mf}{0.26}\PYG{p}{,}
                                         \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{hspace}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{l+m+mf}{0.22}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
                            \PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{)}\PYG{p}{,} \PYG{n}{dpi}\PYG{o}{=}\PYG{l+m+mi}{200}\PYG{p}{)}

    \PYG{k}{for} \PYG{n}{i}\PYG{p}{,} \PYG{n}{row} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{axs}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{for} \PYG{n}{j}\PYG{p}{,} \PYG{n}{ax} \PYG{o+ow}{in} \PYG{n+nb}{enumerate}\PYG{p}{(}\PYG{n}{row}\PYG{p}{)}\PYG{p}{:}
            \PYG{k}{if} \PYG{n}{i} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
                \PYG{n}{lines} \PYG{o}{=} \PYG{n}{roc\PYGZus{}plot}\PYG{p}{(}\PYG{n}{df1}\PYG{p}{,} \PYG{n}{search\PYGZus{}effiencies}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ax}\PYG{p}{)}
            \PYG{k}{else}\PYG{p}{:}
                \PYG{n}{box\PYGZus{}plot}\PYG{p}{(}\PYG{n}{df1}\PYG{p}{,} \PYG{n}{search\PYGZus{}effiencies}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,} \PYG{n}{ax}\PYG{p}{)}

    \PYG{n}{\PYGZus{}asthetics}\PYG{p}{(}\PYG{n}{fig}\PYG{p}{,} \PYG{n}{axs}\PYG{p}{,} \PYG{n}{lines}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{savefig}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{new\PYGZus{}grid.png}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{plt}\PYG{o}{.}\PYG{n}{close}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{if} \PYG{n+nv+vm}{\PYGZus{}\PYGZus{}name\PYGZus{}\PYGZus{}} \PYG{o}{==} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZus{}\PYGZus{}main\PYGZus{}\PYGZus{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:}
    \PYG{n}{main}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}


\section{Pharmacophores}
\label{\detokenize{tutorial:pharmacophores}}
A Pharmacophore Model can be generated directly from a \sphinxcode{\sphinxupquote{hotspots.result.Result}} :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\PYG{n}{r} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{result} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}pharmacophore\PYGZus{}model}\PYG{p}{(}\PYG{n}{identifier}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyFirstPharmacophore}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The Pharmacophore Model can be used in Pharmit or CrossMiner

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result}\PYG{o}{.}\PYG{n}{pharmacophore}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{example.cm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} CrossMiner}
\PYG{n}{result}\PYG{o}{.}\PYG{n}{pharmacophore}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{example.json}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Pharmit}
\end{sphinxVerbatim}

The CSD Python API’s documentation details how the output a “.cm” file can be used for Pharmacophore
searching in CrossMiner. See the link below for details.

\sphinxurl{https://downloads.ccdc.cam.ac.uk/documentation/API/descriptive\_docs/pharmacophore.html}


\chapter{Hotspot Calculation API}
\label{\detokenize{calculation_api:module-hotspots.calculation}}\label{\detokenize{calculation_api:hotspot-calculation-api}}\label{\detokenize{calculation_api::doc}}\index{module@\spxentry{module}!hotspots.calculation@\spxentry{hotspots.calculation}}\index{hotspots.calculation@\spxentry{hotspots.calculation}!module@\spxentry{module}}
The {\hyperref[\detokenize{calculation_api:module-hotspots.calculation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.calculation}}}}} handles the main Fragment Hotspot Maps algorithm. In addition, an alternative pocket burial method, Ghecom, is provided.

The main classes of the {\hyperref[\detokenize{calculation_api:module-hotspots.calculation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.calculation}}}}} module are:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{calculation_api:hotspots.calculation.Buriedness}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.calculation.Buriedness}}}}}

\item {} 
{\hyperref[\detokenize{calculation_api:hotspots.calculation.Runner}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.calculation.Runner}}}}}

\end{itemize}
\begin{description}
\item[{More information about the Fragment Hotspot Maps method is available from:}] \leavevmode\begin{itemize}
\item {} 
Radoux, C.J. et. al., Identifying the Interactions that Determine Fragment Binding at Protein Hotspots J. Med. Chem. 2016, 59 (9), 4314\sphinxhyphen{}4325 {[}dx.doi.org/10.1021/acs.jmedchem.5b01980{]}

\end{itemize}

\item[{More information about the Ghecom method is available from:}] \leavevmode\begin{itemize}
\item {} 
Kawabata T, Go N. Detection of pockets on protein surfaces using small and large probe spheres to find putative ligand binding sites. Proteins 2007; 68: 516\sphinxhyphen{}529

\end{itemize}

\end{description}
\index{Buriedness (class in hotspots.calculation)@\spxentry{Buriedness}\spxextra{class in hotspots.calculation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Buriedness}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.calculation.}}\sphinxbfcode{\sphinxupquote{Buriedness}}}{\emph{\DUrole{n}{protein}}, \emph{\DUrole{n}{out\_grid}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A class to handle the calculation of pocket burial

This provides a python interface for the command\sphinxhyphen{}line tool.
Ghecom is available for download \sphinxhref{http://strcomp.protein.osaka-u.ac.jp/ghecom/download\_src.html}{here!}

NB: Currently this method is only available to linux users

Please ensure you have set the following environment variable:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{export} \PYG{n}{GHECOM\PYGZus{}EXE}\PYG{o}{=}\PYG{o}{\PYGZlt{}}\PYG{n}{path\PYGZus{}to\PYGZus{}ghecom}\PYG{o}{\PYGZgt{}}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protein}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.protein.Protein}}) \textendash{} protein to submit for calculation

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{out\_grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.utilities.Grid}}) \textendash{} the output grid NB: must be initialised so that the bounding box covers the whole protein

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.hotspot\_calculation.Buriedness.Settings}}) \textendash{} 

\end{itemize}

\end{description}\end{quote}
\index{Buriedness.Settings (class in hotspots.calculation)@\spxentry{Buriedness.Settings}\spxextra{class in hotspots.calculation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Buriedness.Settings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Settings}}}{\emph{\DUrole{n}{ghecom\_executable}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{grid\_spacing}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{radius\_min\_large\_sphere}\DUrole{o}{=}\DUrole{default_value}{2.5}}, \emph{\DUrole{n}{radius\_max\_large\_sphere}\DUrole{o}{=}\DUrole{default_value}{9.5}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}M\textquotesingle{}}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A class to handle the buriedness calculation settings using ghecom
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ghecom\_executable}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to ghecom executable NB: should now be set as environment variable

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{grid\_spacing}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} spacing of the results grid. default = 0.5

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{radius\_min\_large\_sphere}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} radius of the smallest sphere

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{radius\_max\_large\_sphere}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} radius of the largest sphere

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} 
options
\begin{itemize}
\item {} 
’D’ilation ‘E’rosion, ‘C’losing(molecular surface), ‘O’pening.

\item {} 
’P’ocket(masuya\_doi),’p’ocket(kawabata\_go),’V’:ca’V’ity, ‘e’roded pocket.

\item {} 
’M’ultiscale\_closing/pocket,’I’nterface\_pocket\_bwn\_two\_chains.

\item {} 
’G’rid\_comparison\_binary ‘g’rid\_comparison\_mutiscale.

\item {} 
’R’ay\sphinxhyphen{}based lig site PSP/visibility calculation.

\item {} 
’L’igand\sphinxhyphen{}grid comparison (\sphinxhyphen{}ilg and \sphinxhyphen{}igA are required){[}P{]}

\end{itemize}


\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{calculate() (hotspots.calculation.Buriedness method)@\spxentry{calculate()}\spxextra{hotspots.calculation.Buriedness method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Buriedness.calculate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{calculate}}}{}{}
runs the buriedness calculation
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxtitleref{hotspots.calculation.\_BuriednessResult}: a class with a \sphinxcode{\sphinxupquote{ccdc.utilities.Grid}} attribute

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Runner (class in hotspots.calculation)@\spxentry{Runner}\spxextra{class in hotspots.calculation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Runner}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.calculation.}}\sphinxbfcode{\sphinxupquote{Runner}}}{\emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

A class for running the Fragment Hotspot Map calculation
\index{Runner.Settings (class in hotspots.calculation)@\spxentry{Runner.Settings}\spxextra{class in hotspots.calculation}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Runner.Settings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Settings}}}{\emph{\DUrole{n}{nrotations}\DUrole{o}{=}\DUrole{default_value}{3000}}, \emph{\DUrole{n}{apolar\_translation\_threshold}\DUrole{o}{=}\DUrole{default_value}{15}}, \emph{\DUrole{n}{polar\_translation\_threshold}\DUrole{o}{=}\DUrole{default_value}{15}}, \emph{\DUrole{n}{polar\_contributions}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{return\_probes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{sphere\_maps}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
Bases: \sphinxcode{\sphinxupquote{object}}

adjusts the default settings for the calculation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nrotations}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of rotations (keep it below 10**6)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{apolar\_translation\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} translate probe to grid points above this threshold. Give lower values for greater sampling. Default 15

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{polar\_translation\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} translate probe to grid points above this threshold. Give lower values for greater sampling. Default 15

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{polar\_contributions}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} allow carbon atoms of probes with polar atoms to contribute to the apolar output map.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{return\_probes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Generate a sorted list of molecule objects, corresponding to probe poses

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sphere\_maps}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} When setting the probe score on the output maps, set it for a sphere (radius 1.5) instead of a single point.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_pdb() (hotspots.calculation.Runner method)@\spxentry{from\_pdb()}\spxextra{hotspots.calculation.Runner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Runner.from_pdb}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_pdb}}}{\emph{\DUrole{n}{pdb\_code}}, \emph{\DUrole{n}{charged\_probes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{probe\_size}\DUrole{o}{=}\DUrole{default_value}{7}}, \emph{\DUrole{n}{buriedness\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ghecom\textquotesingle{}}}, \emph{\DUrole{n}{nprocesses}\DUrole{o}{=}\DUrole{default_value}{3}}, \emph{\DUrole{n}{cavities}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{clear\_tmp}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
generates a result from a pdb code
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdb\_code}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} PDB code

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{charged\_probes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True include positive and negative probes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{probe\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Size of probe in number of heavy atoms (3\sphinxhyphen{}8 atoms)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{buriedness\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Either ‘ghecom’ or ‘ligsite’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nprocesses}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of CPU’s used

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{calculation_api:hotspots.calculation.Runner.Settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.calculation.Runner.Settings}}}}}) \textendash{} holds the calculation settings

\end{itemize}

\item[{Returns}] \leavevmode
a \sphinxcode{\sphinxupquote{hotspots.result.Result}} instance

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{runner} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{runner}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{Result()}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{from\_protein() (hotspots.calculation.Runner method)@\spxentry{from\_protein()}\spxextra{hotspots.calculation.Runner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Runner.from_protein}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_protein}}}{\emph{\DUrole{n}{protein}}, \emph{\DUrole{n}{charged\_probes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{probe\_size}\DUrole{o}{=}\DUrole{default_value}{7}}, \emph{\DUrole{n}{buriedness\_method}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}ghecom\textquotesingle{}}}, \emph{\DUrole{n}{cavities}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{nprocesses}\DUrole{o}{=}\DUrole{default_value}{1}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{buriedness\_grid}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{clear\_tmp}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
generates a result from a protein
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protein}} \textendash{} a \sphinxcode{\sphinxupquote{ccdc.protein.Protein}} instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{charged\_probes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True include positive and negative probes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{probe\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Size of probe in number of heavy atoms (3\sphinxhyphen{}8 atoms)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{buriedness\_method}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Either ‘ghecom’ or ‘ligsite’

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cavities}} \textendash{} Coordinate or \sphinxtitleref{ccdc.cavity.Cavity} or \sphinxtitleref{ccdc.molecule.Molecule} or list specifying the cavity or cavities on which the calculation should be run

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nprocesses}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} number of CPU’s used

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{calculation_api:hotspots.calculation.Runner.Settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.calculation.Runner.Settings}}}}}) \textendash{} holds the sampler settings

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{buriedness\_grid}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.utilities.Grid}}) \textendash{} pre\sphinxhyphen{}calculated buriedness grid

\end{itemize}

\item[{Returns}] \leavevmode
a {\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}} instance

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{protein} \PYG{k+kn}{import} \PYG{n}{Protein}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{protein} \PYG{o}{=} \PYG{n}{Protein}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{path\PYGZus{}to\PYGZus{}protein}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{runner} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{settings} \PYG{o}{=} \PYG{n}{Runner}\PYG{o}{.}\PYG{n}{Settings}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{settings}\PYG{o}{.}\PYG{n}{nrotations} \PYG{o}{=} \PYG{l+m+mi}{1000}  \PYG{c+c1}{\PYGZsh{} fewer rotations increase speed at the expense of accuracy}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{runner}\PYG{o}{.}\PYG{n}{from\PYGZus{}protein}\PYG{p}{(}\PYG{n}{protein}\PYG{p}{,} \PYG{n}{nprocesses}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,} \PYG{n}{settings}\PYG{o}{=}\PYG{n}{settings}\PYG{p}{)}
\PYG{g+go}{Result()}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{from\_superstar() (hotspots.calculation.Runner method)@\spxentry{from\_superstar()}\spxextra{hotspots.calculation.Runner method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{calculation_api:hotspots.calculation.Runner.from_superstar}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{from\_superstar}}}{\emph{\DUrole{n}{protein}}, \emph{\DUrole{n}{superstar\_grids}}, \emph{\DUrole{n}{buriedness}}, \emph{\DUrole{n}{charged\_probes}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{probe\_size}\DUrole{o}{=}\DUrole{default_value}{7}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{clear\_tmp}\DUrole{o}{=}\DUrole{default_value}{False}}}{}
calculate hotspot maps from precalculated superstar maps. This enables more effective parallelisation and reuse
of object such as the Buriedness grids
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protein}} \textendash{} a \sphinxcode{\sphinxupquote{ccdc.protein.Protein}} instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{superstar\_grids}} \textendash{} a \sphinxcode{\sphinxupquote{hotspots.atomic\_hotspot\_calculation.\_AtomicHotspotResult}} instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{buriedness}} \textendash{} a \sphinxcode{\sphinxupquote{hotspots.grid\_extension.Grid}} instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{charged\_probes}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, include positive and negative probes

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{probe\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Size of probe in number of heavy atoms (3\sphinxhyphen{}8 atoms)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} \textendash{} \sphinxtitleref{hotspots.calculation.Runner.Settings} settings: holds the sampler settings

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{clear\_tmp}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, clear the temporary directory

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Hotspot IO API}
\label{\detokenize{hs_io_api:module-hotspots.hs_io}}\label{\detokenize{hs_io_api:hotspot-io-api}}\label{\detokenize{hs_io_api::doc}}\index{module@\spxentry{module}!hotspots.hs\_io@\spxentry{hotspots.hs\_io}}\index{hotspots.hs\_io@\spxentry{hotspots.hs\_io}!module@\spxentry{module}}
The {\hyperref[\detokenize{hs_io_api:module-hotspots.hs_io}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_io}}}}} module was created to facilitate easy reading and
writing of Fragment Hotspot Map results.

There are multiple components to a \sphinxcode{\sphinxupquote{hotspots.result.Result}} including, the
protein, interaction grids and buriedness grid. It is therefore tedious to manually
read/write using the various class readers/writers. The Hotspots I/O organises this
for the user and can handle single \sphinxcode{\sphinxupquote{hotspots.result.Result}} or lists of
\sphinxcode{\sphinxupquote{hotspots.result.Result}}.

The main classes of the \sphinxcode{\sphinxupquote{hotspots.io}} module are:
\begin{itemize}
\item {} 
\sphinxcode{\sphinxupquote{hotspots.io.HotspotWriter}}

\item {} 
\sphinxcode{\sphinxupquote{hotspots.io.HotspotReader}}

\end{itemize}
\index{HotspotReader (class in hotspots.hs\_io)@\spxentry{HotspotReader}\spxextra{class in hotspots.hs\_io}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_io_api:hotspots.hs_io.HotspotReader}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.hs\_io.}}\sphinxbfcode{\sphinxupquote{HotspotReader}}}{\emph{\DUrole{n}{path}}}{}
A class to organise the reading of a \sphinxcode{\sphinxupquote{hotspots.result.Result}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to the result directory (can be .zip directory)

\end{description}\end{quote}
\index{read() (hotspots.hs\_io.HotspotReader method)@\spxentry{read()}\spxextra{hotspots.hs\_io.HotspotReader method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_io_api:hotspots.hs_io.HotspotReader.read}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{read}}}{\emph{\DUrole{n}{identifier}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
creates a single or list of \sphinxcode{\sphinxupquote{hotspots.result.Result}} instance(s)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} for directories containing multiple Fragment Hotspot Map results,

\end{description}\end{quote}

identifier is the subdirectory for which a \sphinxcode{\sphinxupquote{hotspots.result.Result}} is requried
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\sphinxtitleref{hotspots.result.Result} a Fragment Hotspot Map result

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}io} \PYG{k+kn}{import} \PYG{n}{HotspotReader}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{path} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}path\PYGZus{}to\PYGZus{}results\PYGZus{}directory\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{HotspotReader}\PYG{p}{(}\PYG{n}{path}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{HotspotWriter (class in hotspots.hs\_io)@\spxentry{HotspotWriter}\spxextra{class in hotspots.hs\_io}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_io_api:hotspots.hs_io.HotspotWriter}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.hs\_io.}}\sphinxbfcode{\sphinxupquote{HotspotWriter}}}{\emph{\DUrole{n}{path}}, \emph{\DUrole{n}{visualisation}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}pymol\textquotesingle{}}}, \emph{\DUrole{n}{grid\_extension}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}.grd\textquotesingle{}}}, \emph{\DUrole{n}{zip\_results}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
A class to handle the writing of a :class\textasciigrave{}hotspots.result.Result\textasciigrave{}. Additionally, creation of the
PyMol visualisation scripts are handled here.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to output directory

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{visualisation}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} “pymol” or “ngl” currently only PyMOL available

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{grid\_extension}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} “.grd”, “.ccp4” and “.acnt” supported

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{zip\_results}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the result directory will be compressed. (recommended)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{hs_io_api:hotspots.hs_io.HotspotWriter.Settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.hs\_io.HotspotWriter.Settings}}}}}) \textendash{} settings

\end{itemize}

\end{description}\end{quote}
\index{HotspotWriter.Settings (class in hotspots.hs\_io)@\spxentry{HotspotWriter.Settings}\spxextra{class in hotspots.hs\_io}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_io_api:hotspots.hs_io.HotspotWriter.Settings}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Settings}}}
A class to hold the {\hyperref[\detokenize{hs_io_api:hotspots.hs_io.HotspotWriter}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_io.HotspotWriter}}}}} settings

\end{fulllineitems}

\index{compress() (hotspots.hs\_io.HotspotWriter method)@\spxentry{compress()}\spxextra{hotspots.hs\_io.HotspotWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_io_api:hotspots.hs_io.HotspotWriter.compress}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{compress}}}{\emph{\DUrole{n}{archive\_name}}, \emph{\DUrole{n}{delete\_directory}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
compresses the output directory created for this \sphinxcode{\sphinxupquote{hotspots.HotspotResults}} instance, and
removes the directory by default. The zipped file can be loaded directly into a new
\sphinxcode{\sphinxupquote{hotspots.HotspotResults}} instance using the
\sphinxcode{\sphinxupquote{from\_zip\_dir()}} function
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{archive\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} file path

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{delete\_directory}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} remove the out directory once it has been zipped

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{write() (hotspots.hs\_io.HotspotWriter method)@\spxentry{write()}\spxextra{hotspots.hs\_io.HotspotWriter method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_io_api:hotspots.hs_io.HotspotWriter.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{\DUrole{n}{hr}}}{}
writes the Fragment Hotspot Maps result to the output directory and create the pymol visualisation file
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{hr}} (\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.result.Result}}) \textendash{} a Fragment Hotspot Maps result or list of results

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}io} \PYG{k+kn}{import} \PYG{n}{HotspotWriter}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{Runner}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{out\PYGZus{}dir} \PYG{o}{=} \PYG{o}{\PYGZlt{}}\PYG{n}{path\PYGZus{}to\PYGZus{}out}\PYG{o}{\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n}{HotspotWriter}\PYG{p}{(}\PYG{n}{out\PYGZus{}dir}\PYG{p}{)} \PYG{k}{as} \PYG{n}{w}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{w}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Result API}
\label{\detokenize{result_api:module-hotspots.result}}\label{\detokenize{result_api:result-api}}\label{\detokenize{result_api::doc}}\index{module@\spxentry{module}!hotspots.result@\spxentry{hotspots.result}}\index{hotspots.result@\spxentry{hotspots.result}!module@\spxentry{module}}
The {\hyperref[\detokenize{result_api:module-hotspots.result}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result}}}}} contains classes to extract valuable information from the calculated Fragment Hotspot Maps.
\begin{description}
\item[{The main classes of the {\hyperref[\detokenize{result_api:module-hotspots.result}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result}}}}} module are:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}}

\item {} 
{\hyperref[\detokenize{result_api:hotspots.result.Extractor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Extractor}}}}}

\end{itemize}

\end{description}

{\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}} can be generated using the {\hyperref[\detokenize{calculation_api:module-hotspots.calculation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.calculation}}}}} module

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\PYG{g+go}{\PYGZgt{}\PYGZgt{}\PYGZgt{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

either

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pdb\PYGZus{}code}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

or

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{protein} \PYG{k+kn}{import} \PYG{n}{Protein}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{protein} \PYG{o}{=} \PYG{n}{Protein}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{path\PYGZus{}to\PYGZus{}protein}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{from\PYGZus{}protein}\PYG{p}{(}\PYG{n}{protein}\PYG{p}{)}
\end{sphinxVerbatim}

The {\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}} is the central class for the entire API. Every module either feeds into creating
a {\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}} instance or uses it to generate derived data structures.

The {\hyperref[\detokenize{result_api:hotspots.result.Extractor}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Extractor}}}}} enables the main result to be broken down based on molecular volumes. This
produces molecule sized descriptions of the cavity and aids tractibility analysis and pharmacophoric generation.
\index{Extractor (class in hotspots.result)@\spxentry{Extractor}\spxextra{class in hotspots.result}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Extractor}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.result.}}\sphinxbfcode{\sphinxupquote{Extractor}}}{\emph{\DUrole{n}{hr}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
A class to handle the extraction of molecular volumes from a Fragment Hotspot Map result
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hr}} (\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.HotspotResults}}) \textendash{} A Fragment Hotspot Maps result

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} (\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.Extractor.Settings}}) \textendash{} Extractor settings

\end{itemize}

\end{description}\end{quote}
\index{Extractor.Settings (class in hotspots.result)@\spxentry{Extractor.Settings}\spxextra{class in hotspots.result}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Extractor.Settings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Settings}}}{\emph{\DUrole{n}{volume}\DUrole{o}{=}\DUrole{default_value}{150}}, \emph{\DUrole{n}{cutoff}\DUrole{o}{=}\DUrole{default_value}{14}}, \emph{\DUrole{n}{spacing}\DUrole{o}{=}\DUrole{default_value}{0.5}}, \emph{\DUrole{n}{mvon}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
Default settings for hotspot extraction
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{volume}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} required volume (default = 150)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cutoff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} only features above this value are considered (default = 14)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{spacing}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} grid spacing, (default = 0.5)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mvon}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Run Max value of neighbours (default = True)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{extract\_volume() (hotspots.result.Extractor method)@\spxentry{extract\_volume()}\spxextra{hotspots.result.Extractor method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Extractor.extract_volume}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{extract\_volume}}}{\emph{\DUrole{n}{volume}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}125\textquotesingle{}}}}{}
Returns a HotspotResult with a restricted volume
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{volume}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} target map volume

\item[{Return hotspots.result.Results\sphinxtitleref{hotspots.result.Results}}] \leavevmode
A fresh result object

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Results (class in hotspots.result)@\spxentry{Results}\spxextra{class in hotspots.result}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.result.}}\sphinxbfcode{\sphinxupquote{Results}}}{\emph{\DUrole{n}{super\_grids}}, \emph{\DUrole{n}{protein}}, \emph{\DUrole{n}{buriedness}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{pharmacophore}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
A class to handle the results of the Fragment Hotspot Map calcation and to organise subsequent analysis
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{super\_grids}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} key = probe identifier and value = grid

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protein}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.protein.Protein}}) \textendash{} target protein

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{buriedness}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.utilities.Grid}}) \textendash{} the buriedness grid

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pharmacophore}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} if True, a pharmacophore will be generated

\end{itemize}

\end{description}\end{quote}
\index{atomic\_volume\_overlap() (hotspots.result.Results method)@\spxentry{atomic\_volume\_overlap()}\spxextra{hotspots.result.Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results.atomic_volume_overlap}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{atomic\_volume\_overlap}}}{\emph{\DUrole{n}{mol}}}{}
for a given mol, return a dictionary of dictionaries containing the percentage overlap of each atoms
VDW radius with the Hotspot Grids.

\{“donor”: \{“atomic\_label”: percentage\_overlap\}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{mol}} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{from\_grid\_ensembles() (hotspots.result.Results static method)@\spxentry{from\_grid\_ensembles()}\spxextra{hotspots.result.Results static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results.from_grid_ensembles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{from\_grid\_ensembles}}}{\emph{\DUrole{n}{res\_list}}, \emph{\DUrole{n}{prot\_name}}, \emph{\DUrole{n}{charged}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}max\textquotesingle{}}}}{}
\sphinxstyleemphasis{Experimental feature}

Creates ensemble map from a list of Results. Structures in the ensemble have to aligned by the
binding site of interest prior to the hotspots calculation.

TODO: Move to the calculation module?
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{res\_list}} \textendash{} list of \sphinxtitleref{hotspots.result.Results}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{prot\_name}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} str

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{out\_dir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to output directory

\end{itemize}

\item[{Returns}] \leavevmode
a {\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}} instance

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_difference\_map() (hotspots.result.Results method)@\spxentry{get\_difference\_map()}\spxextra{hotspots.result.Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results.get_difference_map}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_difference\_map}}}{\emph{\DUrole{n}{other}}, \emph{\DUrole{n}{tolerance}}}{}
\sphinxstyleemphasis{Experimental feature.}
Generates maps to highlight selectivity for a target over an off target cavity. Proteins should be aligned
by the binding site of interest prior to calculation.
High scoring regions of a map represent areas of favourable interaction in the target binding site, not
present in off target binding site
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{other}} \textendash{} a {\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}} instance

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tolerance}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} how many grid points away to apply filter to

\end{itemize}

\item[{Returns}] \leavevmode
a {\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.result.Results}}}}} instance

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_pharmacophore\_model() (hotspots.result.Results method)@\spxentry{get\_pharmacophore\_model()}\spxextra{hotspots.result.Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results.get_pharmacophore_model}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_pharmacophore\_model}}}{\emph{\DUrole{n}{identifier}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}id\_01\textquotesingle{}}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{5}}}{}
Generates a \sphinxcode{\sphinxupquote{hotspots.hotspot\_pharmacophore.PharmacophoreModel}} instance from peaks in the hotspot maps

TODO: investigate using feature recognition to go from grids to features.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Identifier for displaying multiple models at once

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cutoff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The score cutoff used to identify islands in the maps. One peak will be identified per island

\end{itemize}

\item[{Returns}] \leavevmode
a \sphinxcode{\sphinxupquote{hotspots.hotspot\_pharmacophore.PharmacophoreModel}} instance

\end{description}\end{quote}

\end{fulllineitems}

\index{map\_values() (hotspots.result.Results method)@\spxentry{map\_values()}\spxextra{hotspots.result.Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results.map_values}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{map\_values}}}{}{}
get the number zero grid points for the Fragment Hotspot Result
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
dict of str(probe type) by a \sphinxcode{\sphinxupquote{numpy.array}} (non\sphinxhyphen{}zero grid point scores)

\end{description}\end{quote}

\end{fulllineitems}

\index{percentage\_matched\_atoms() (hotspots.result.Results method)@\spxentry{percentage\_matched\_atoms()}\spxextra{hotspots.result.Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results.percentage_matched_atoms}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{percentage\_matched\_atoms}}}{\emph{\DUrole{n}{mol}}, \emph{\DUrole{n}{threshold}}, \emph{\DUrole{n}{match\_atom\_types}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
for a given molecule, the ‘percentage match’ is given by the percentage of atoms
which overlap with the hotspot result (over a given overlap threshol)
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mol}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} \textendash{} 

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{match\_atom\_types}} \textendash{} 

\end{itemize}

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{score() (hotspots.result.Results method)@\spxentry{score()}\spxextra{hotspots.result.Results method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{result_api:hotspots.result.Results.score}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{score}}}{\emph{\DUrole{n}{obj}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{tolerance}\DUrole{o}{=}\DUrole{default_value}{2}}}{}
annotate protein, molecule or self with Fragment Hotspot scores
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{obj}} \textendash{} \sphinxtitleref{ccdc.protein.Protein}, \sphinxtitleref{ccdc.molecule.Molecule} or \sphinxtitleref{hotsptos.result.Results} (find the median)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tolerance}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} the search radius around each point

\end{itemize}

\item[{Returns}] \leavevmode
scored obj, either \sphinxcode{\sphinxupquote{ccdc.protein.Protein}}, \sphinxcode{\sphinxupquote{ccdc.molecule.Molecule}} or \sphinxcode{\sphinxupquote{hotspot.result.Results}}

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result}          \PYG{c+c1}{\PYGZsh{} example \PYGZdq{}1hcl\PYGZdq{}}
\PYG{g+go}{\PYGZlt{}hotspots.result.Results object at 0x000000001B657940\PYGZgt{}}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{numpy} \PYG{k+kn}{import} \PYG{n}{np}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{p} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{score}\PYG{p}{(}\PYG{n}{result}\PYG{o}{.}\PYG{n}{protein}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} scored protein}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{np}\PYG{o}{.}\PYG{n}{median}\PYG{p}{(}\PYG{p}{[}\PYG{n}{a}\PYG{o}{.}\PYG{n}{partial\PYGZus{}charge} \PYG{k}{for} \PYG{n}{a} \PYG{o+ow}{in} \PYG{n}{p}\PYG{o}{.}\PYG{n}{atoms} \PYG{k}{if} \PYG{n}{a}\PYG{o}{.}\PYG{n}{partial\PYGZus{}charge} \PYG{o}{\PYGZgt{}} \PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{g+go}{8.852499961853027}
\end{sphinxVerbatim}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Hotspot Pharmacophore API}
\label{\detokenize{hs_pharmacophore_api:module-hotspots.hs_pharmacophore}}\label{\detokenize{hs_pharmacophore_api:hotspot-pharmacophore-api}}\label{\detokenize{hs_pharmacophore_api::doc}}\index{module@\spxentry{module}!hotspots.hs\_pharmacophore@\spxentry{hotspots.hs\_pharmacophore}}\index{hotspots.hs\_pharmacophore@\spxentry{hotspots.hs\_pharmacophore}!module@\spxentry{module}}
The {\hyperref[\detokenize{hs_pharmacophore_api:module-hotspots.hs_pharmacophore}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore}}}}} module contains classes for the
conversion of Grid objects to pharmacophore models.

The main class of the {\hyperref[\detokenize{hs_pharmacophore_api:module-hotspots.hs_pharmacophore}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore}}}}} module is:
\begin{itemize}
\item {} 
{\hyperref[\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore.PharmacophoreModel}}}}}

\end{itemize}

A Pharmacophore Model can be generated directly from a \sphinxcode{\sphinxupquote{hotspots.result.Result}} :

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}pharmacophore\PYGZus{}model}\PYG{p}{(}\PYG{n}{identifier}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{MyFirstPharmacophore}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

The Pharmacophore Model can be used in Pharmit or CrossMiner

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result}\PYG{o}{.}\PYG{n}{pharmacophore}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{example.cm}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} CrossMiner}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result}\PYG{o}{.}\PYG{n}{pharmacophore}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{example.json}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}    \PYG{c+c1}{\PYGZsh{} Pharmit}
\end{sphinxVerbatim}
\begin{description}
\item[{More information about CrossMiner is available:}] \leavevmode\begin{itemize}
\item {} 
Korb O, Kuhn B, hert J, Taylor N, Cole J, Groom C, Stahl M “Interactive and Versatile Navigation of Structural Databases” J Med Chem, 2016, 59(9):4257, {[}DOI: 10.1021/acs.jmedchem.5b01756{]}

\end{itemize}

\item[{More information about Pharmit is available:}] \leavevmode\begin{itemize}
\item {} 
Jocelyn Sunseri, David Ryan Koes; Pharmit: interactive exploration of chemical space, Nucleic Acids Research, Volume 44, Issue W1, 8 July 2016, Pages W442\sphinxhyphen{}W448 {[}DIO: 10.1093/nar/gkw287{]}

\end{itemize}

\end{description}
\index{PharmacophoreModel (class in hotspots.hs\_pharmacophore)@\spxentry{PharmacophoreModel}\spxextra{class in hotspots.hs\_pharmacophore}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore.}}\sphinxbfcode{\sphinxupquote{PharmacophoreModel}}}{\emph{\DUrole{n}{settings}}, \emph{\DUrole{n}{identifier}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{features}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{protein}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{dic}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
A class to handle a Pharmacophore Model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.Settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.hs\_pharmacophore.PharmacophoreModel.Settings}}}}}) \textendash{} Pharmacophore Model settings

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Model identifier

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{features}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of  :class:hotspots.hs\_pharmacophore.\_PharmacophoreFeatures

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protein}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.protein.Protein}}) \textendash{} a protein

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dic}} (\sphinxstyleliteralemphasis{\sphinxupquote{dict}}) \textendash{} key = grid identifier(interaction type), value = \sphinxcode{\sphinxupquote{ccdc.utilities.Grid}}

\end{itemize}

\end{description}\end{quote}
\index{PharmacophoreModel.Settings (class in hotspots.hs\_pharmacophore)@\spxentry{PharmacophoreModel.Settings}\spxextra{class in hotspots.hs\_pharmacophore}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.Settings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{Settings}}}{\emph{\DUrole{n}{feature\_boundary\_cutoff}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{max\_hbond\_dist}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{radius}\DUrole{o}{=}\DUrole{default_value}{1.0}}, \emph{\DUrole{n}{vector\_on}\DUrole{o}{=}\DUrole{default_value}{False}}, \emph{\DUrole{n}{transparency}\DUrole{o}{=}\DUrole{default_value}{0.6}}, \emph{\DUrole{n}{excluded\_volume}\DUrole{o}{=}\DUrole{default_value}{True}}, \emph{\DUrole{n}{binding\_site\_radius}\DUrole{o}{=}\DUrole{default_value}{12}}}{}
settings available for adjustment
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{feature\_boundary\_cutoff}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} The map score cutoff used to generate islands

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_hbond\_dist}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Furthest acceptable distance for a hydrogen bonding partner (from polar feature)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Sphere radius

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{vector\_on}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} Include interaction vector

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{transparency}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Set transparency of sphere

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{excluded\_volume}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If True, the CrossMiner pharmacophore will contain excluded volume spheres

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{binding\_site\_radius}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Radius of search for binding site calculation, used for excluded volume

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{from\_hotspot() (hotspots.hs\_pharmacophore.PharmacophoreModel static method)@\spxentry{from\_hotspot()}\spxextra{hotspots.hs\_pharmacophore.PharmacophoreModel static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.from_hotspot}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{from\_hotspot}}}{\emph{\DUrole{n}{result}}, \emph{\DUrole{n}{identifier}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}id\_01\textquotesingle{}}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{min\_island\_size}\DUrole{o}{=}\DUrole{default_value}{5}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
creates a pharmacophore model from a Fragment Hotspot Map result

(included for completeness, equivalent to \sphinxtitleref{hotspots.result.Result.get\_pharmacophore()})
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{result}} (\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.result.Result}}) \textendash{} a Fragment Hotspot Maps result (or equivalent)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} Pharmacophore Model identifier

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} values above this value

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.Settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.hs\_pharmacophore.PharmacophoreModel.Settings}}}}}) \textendash{} settings

\end{itemize}

\item[{Returns}] \leavevmode
{\hyperref[\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore.PharmacophoreModel}}}}}

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}pharmacophore} \PYG{k+kn}{import} \PYG{n}{PharmacophoreModel}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{r} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{r}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{PharmacophoreModel}\PYG{p}{(}\PYG{n}{result}\PYG{p}{,} \PYG{n}{identifier}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{pharmacophore}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{from\_ligands() (hotspots.hs\_pharmacophore.PharmacophoreModel static method)@\spxentry{from\_ligands()}\spxextra{hotspots.hs\_pharmacophore.PharmacophoreModel static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.from_ligands}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{from\_ligands}}}{\emph{\DUrole{n}{ligands}}, \emph{\DUrole{n}{identifier}}, \emph{\DUrole{n}{protein}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{settings}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
creates a Pharmacophore Model from a collection of overlaid ligands
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ligands}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc}}\sphinxstyleliteralemphasis{\sphinxupquote{,}}\sphinxstyleliteralemphasis{\sphinxupquote{molecule.Molecule}}) \textendash{} ligands from which the Model is created

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} identifier for the Pharmacophore Model

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protein}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.protein.Protein}}) \textendash{} target system that the model has been created for

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{settings}} ({\hyperref[\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.Settings}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.hs\_pharmacophore.PharmacophoreModel.Settings}}}}}) \textendash{} Pharmacophore Model settings

\end{itemize}

\item[{Returns}] \leavevmode
{\hyperref[\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore.PharmacophoreModel}}}}}

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{io} \PYG{k+kn}{import} \PYG{n}{MoleculeReader}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}pharmacophore} \PYG{k+kn}{import} \PYG{n}{PharmacophoreModel}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mols} \PYG{o}{=} \PYG{n}{MoleculeReader}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ligand\PYGZus{}overlay\PYGZus{}model.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{PharmacophoreModel}\PYG{o}{.}\PYG{n}{from\PYGZus{}ligands}\PYG{p}{(}\PYG{n}{mols}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ligand\PYGZus{}overlay\PYGZus{}pharmacophore}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} write to .json and search in pharmit}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{model.json}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{from\_pdb() (hotspots.hs\_pharmacophore.PharmacophoreModel static method)@\spxentry{from\_pdb()}\spxextra{hotspots.hs\_pharmacophore.PharmacophoreModel static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.from_pdb}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{from\_pdb}}}{\emph{\DUrole{n}{pdb\_code}}, \emph{\DUrole{n}{chain}}, \emph{\DUrole{n}{representatives}\DUrole{o}{=}\DUrole{default_value}{None}}, \emph{\DUrole{n}{identifier}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}LigandBasedPharmacophore\textquotesingle{}}}}{}
creates a Pharmacophore Model from a PDB code.

This method is used for the creation of Ligand\sphinxhyphen{}Based pharmacophores. The PDB is searched for protein\sphinxhyphen{}ligand
complexes of the same UniProt code as the input. These PDB’s are align, the ligands are clustered and density
of atom types a given point is assigned to a grid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{pdb\_code}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} single PDB code from the target system

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{chain}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} chain of interest

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{out\_dir}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to output directory

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{representatives}} \textendash{} path to .dat file containing previously clustered data (time saver)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{identifier}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} identifier for the Pharmacophore Model

\end{itemize}

\item[{Returns}] \leavevmode
{\hyperref[\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore.PharmacophoreModel}}}}}

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}pharmacophore} \PYG{k+kn}{import} \PYG{n}{PharmacophoreModel}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{result} \PYG{k+kn}{import} \PYG{n}{Results}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}io} \PYG{k+kn}{import} \PYG{n}{HotspotWriter}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{protein} \PYG{k+kn}{import} \PYG{n}{Protein}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{pdb\PYGZus{}python\PYGZus{}api} \PYG{k+kn}{import} \PYG{n}{PDBResult}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} get the PDB ligand\PYGZhy{}based Pharmacophore for CDK2}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{PharmacophoreModel}\PYG{o}{.}\PYG{n}{from\PYGZus{}pdb}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} the models grid data is stored as PharmacophoreModel.dic}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{c+c1}{\PYGZsh{} download the PDB file and create a Results}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{PDBResult}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{download}\PYG{p}{(}\PYG{o}{\PYGZlt{}}\PYG{n}{output\PYGZus{}directory}\PYG{o}{\PYGZgt{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{Result}\PYG{p}{(}\PYG{n}{protein}\PYG{o}{=}\PYG{n}{Protein}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}output\PYGZus{}directory\PYGZgt{}/1hcl.pdb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{p}{,} \PYG{n}{super\PYGZus{}grids}\PYG{o}{=}\PYG{n}{model}\PYG{o}{.}\PYG{n}{dic}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k}{with} \PYG{n}{HotspotWriter}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}output\PYGZus{}directory\PYGZgt{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)} \PYG{k}{as} \PYG{n}{w}\PYG{p}{:}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }    \PYG{n}{w}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{result}\PYG{p}{)}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{rank\_features() (hotspots.hs\_pharmacophore.PharmacophoreModel method)@\spxentry{rank\_features()}\spxextra{hotspots.hs\_pharmacophore.PharmacophoreModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.rank_features}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{rank\_features}}}{\emph{\DUrole{n}{max\_features}\DUrole{o}{=}\DUrole{default_value}{4}}, \emph{\DUrole{n}{feature\_threshold}\DUrole{o}{=}\DUrole{default_value}{0}}, \emph{\DUrole{n}{force\_apolar}\DUrole{o}{=}\DUrole{default_value}{True}}}{}
orders features by score
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_features}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} maximum number of features returned

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{feature\_threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} only features above this value are considered

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{force\_apolar}} \textendash{} ensures at least one point is apolar

\end{itemize}

\item[{Returns}] \leavevmode
list of features

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}io} \PYG{k+kn}{import} \PYG{n}{HotspotReader}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{result} \PYG{o}{=} \PYG{n}{HotspotReader}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{out.zip}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model} \PYG{o}{=} \PYG{n}{result}\PYG{o}{.}\PYG{n}{get\PYGZus{}pharmacophore\PYGZus{}model}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{features}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{38}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{model}\PYG{o}{.}\PYG{n}{rank\PYGZus{}features}\PYG{p}{(}\PYG{n}{max\PYGZus{}features}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{print}\PYG{p}{(}\PYG{n+nb}{len}\PYG{p}{(}\PYG{n}{model}\PYG{o}{.}\PYG{n}{features}\PYG{p}{)}\PYG{p}{)}
\PYG{g+go}{5}
\end{sphinxVerbatim}

\end{fulllineitems}

\index{write() (hotspots.hs\_pharmacophore.PharmacophoreModel method)@\spxentry{write()}\spxextra{hotspots.hs\_pharmacophore.PharmacophoreModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.PharmacophoreModel.write}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{write}}}{\emph{\DUrole{n}{fname}}}{}
writes out pharmacophore. Supported formats:
\begin{itemize}
\item {} 
“.cm” (\sphinxstyleemphasis{CrossMiner}),

\item {} 
“.json” (\sphinxhref{http://pharmit.csb.pitt.edu/search.html/}{Pharmit}),

\item {} 
“.py” (\sphinxstyleemphasis{PyMOL}),

\item {} 
“.csv”,

\item {} 
“.mol2”

\end{itemize}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{fname}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to output file

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{tanimoto\_dist() (in module hotspots.hs\_pharmacophore)@\spxentry{tanimoto\_dist()}\spxextra{in module hotspots.hs\_pharmacophore}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_pharmacophore_api:hotspots.hs_pharmacophore.tanimoto_dist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{hotspots.hs\_pharmacophore.}}\sphinxbfcode{\sphinxupquote{tanimoto\_dist}}}{\emph{\DUrole{n}{a}}, \emph{\DUrole{n}{b}}}{}
calculate the tanimoto distance between two fingerprint arrays
:param a:
:param b:
:return:

\end{fulllineitems}



\chapter{Hotspot Docking API}
\label{\detokenize{hs_docking_api:module-hotspots.hs_docking}}\label{\detokenize{hs_docking_api:hotspot-docking-api}}\label{\detokenize{hs_docking_api::doc}}\index{module@\spxentry{module}!hotspots.hs\_docking@\spxentry{hotspots.hs\_docking}}\index{hotspots.hs\_docking@\spxentry{hotspots.hs\_docking}!module@\spxentry{module}}
The {\hyperref[\detokenize{hs_docking_api:module-hotspots.hs_docking}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_docking}}}}} module contains functionality which
faciliates the \sphinxstylestrong{automatic} application of insights from Fragment
Hotspot Maps to docking.

This module is designed to extend the existing CSD python API
\begin{description}
\item[{More information about the CSD python API is available:}] \leavevmode\begin{itemize}
\item {} 
The Cambridge Structural Database C.R. Groom, I. J. Bruno, M. P. Lightfoot and S. C. Ward, Acta Crystallographica Section B, B72, 171\sphinxhyphen{}179, 2016 {[}DOI: 10.1107/S2052520616003954{]}

\item {} 
CSD python API 2.0.0 \sphinxhref{https://downloads.ccdc.cam.ac.uk/documentation/API/}{documentation}

\end{itemize}

\item[{More information about the GOLD method is available:}] \leavevmode\begin{itemize}
\item {} 
Development and Validation of a Genetic Algorithm for Flexible Docking G. Jones, P. Willett, R. C. Glen, A. R. Leach and R. Taylor, J. Mol. Biol., 267, 727\sphinxhyphen{}748, 1997 {[}DOI: 10.1006/jmbi.1996.0897{]}

\end{itemize}

\end{description}
\index{DockerSettings (class in hotspots.hs\_docking)@\spxentry{DockerSettings}\spxextra{class in hotspots.hs\_docking}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_docking_api:hotspots.hs_docking.DockerSettings}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.hs\_docking.}}\sphinxbfcode{\sphinxupquote{DockerSettings}}}{\emph{\DUrole{n}{\_settings}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
A class to handle the integration of Fragment Hotspot Map data with GOLD

This class is designed to mirror the existing CSD python API for smooth integration. For use, import this class
as the docking settings rather than directly from the Docking API.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{docking} \PYG{k+kn}{import} \PYG{n}{Docker}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{ccdc}\PYG{n+nn}{.}\PYG{n+nn}{protein} \PYG{k+kn}{import} \PYG{n}{Protein}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{calculation} \PYG{k+kn}{import} \PYG{n}{Runner}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{hotspots}\PYG{n+nn}{.}\PYG{n+nn}{hs\PYGZus{}docking} \PYG{k+kn}{import} \PYG{n}{DockerSettings}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{protein} \PYG{o}{=} \PYG{n}{Protein}\PYG{o}{.}\PYG{n}{from\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl.pdb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{runner} \PYG{o}{=} \PYG{n}{Runner}\PYG{p}{(}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{hs} \PYG{o}{=} \PYG{n}{runner}\PYG{o}{.}\PYG{n}{from\PYGZus{}protein}\PYG{p}{(}\PYG{n}{protein}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}protein\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{1hcl.pdb}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}ligand\PYGZus{}file}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{dock\PYGZus{}me.mol2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{n}{ndocks}\PYG{o}{=}\PYG{l+m+mi}{25}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{constraints} \PYG{o}{=} \PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{HotspotHBondConstraint}\PYG{o}{.}\PYG{n}{from\PYGZus{}hotspot}\PYG{p}{(}\PYG{n}{protein}\PYG{o}{=}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{proteins}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{,} \PYG{n}{hr}\PYG{o}{=}\PYG{n}{hs}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{o}{.}\PYG{n}{add\PYGZus{}constraint}\PYG{p}{(}\PYG{n}{constraints}\PYG{p}{)}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{docker}\PYG{o}{.}\PYG{n}{dock}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{docker}\PYG{o}{.}\PYG{n}{Results}\PYG{p}{(}\PYG{n}{docker}\PYG{o}{.}\PYG{n}{settings}\PYG{p}{)}\PYG{o}{.}\PYG{n}{ligands}
\end{sphinxVerbatim}
\index{DockerSettings.HotspotHBondConstraint (class in hotspots.hs\_docking)@\spxentry{DockerSettings.HotspotHBondConstraint}\spxextra{class in hotspots.hs\_docking}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_docking_api:hotspots.hs_docking.DockerSettings.HotspotHBondConstraint}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxbfcode{\sphinxupquote{HotspotHBondConstraint}}}{\emph{\DUrole{n}{atoms}}, \emph{\DUrole{n}{weight}\DUrole{o}{=}\DUrole{default_value}{5.0}}, \emph{\DUrole{n}{min\_hbond\_score}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{\_constraint}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
A protein HBond constraint constructed from a hotspot
Assign Protein Hbond constraints based on the highest scoring interactions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{atoms}} (\sphinxstyleliteralemphasis{\sphinxupquote{list}}) \textendash{} list of \sphinxcode{\sphinxupquote{ccdc.molecule.Atom}} instances from the protein. \sphinxstyleemphasis{NB: The atoms should be donatable hydrogens or acceptor atoms.}

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} \textendash{} the penalty to be applied for no atom of the list forming an HBond.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{min\_hbond\_score}} \textendash{} the minimal score of an HBond to be considered a valid HBond.

\end{itemize}

\end{description}\end{quote}
\index{create() (hotspots.hs\_docking.DockerSettings.HotspotHBondConstraint static method)@\spxentry{create()}\spxextra{hotspots.hs\_docking.DockerSettings.HotspotHBondConstraint static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_docking_api:hotspots.hs_docking.DockerSettings.HotspotHBondConstraint.create}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{create}}}{\emph{\DUrole{n}{protein}}, \emph{\DUrole{n}{hr}}, \emph{\DUrole{n}{max\_constraints}\DUrole{o}{=}\DUrole{default_value}{2}}, \emph{\DUrole{n}{weight}\DUrole{o}{=}\DUrole{default_value}{5.0}}, \emph{\DUrole{n}{min\_hbond\_score}\DUrole{o}{=}\DUrole{default_value}{0.001}}, \emph{\DUrole{n}{cutoff}\DUrole{o}{=}\DUrole{default_value}{10}}}{}
creates a \sphinxcode{\sphinxupquote{hotspots.hs\_docking.HotspotHBondConstraint}}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{protein}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.protein.Protein}}) \textendash{} the protein to be used for docking

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hr}} (\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.calculation.Result}}) \textendash{} a result from Fragment Hotspot Maps

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{max\_constraints}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} max number of constraints

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{weight}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} the constraint weight (default to be determined)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{min\_hbond\_score}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} float between 0.0 (bad) and 1.0 (good) determining the minimum hydrogen bond quality in the solutions.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cutoff}} \textendash{} minimum score required to assign the constraint

\end{itemize}

\item[{Return list}] \leavevmode
list of \sphinxcode{\sphinxupquote{hotspots.hs\_docking.HotspotHBondConstraint}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{generate\_fitting\_points() (hotspots.hs\_docking.DockerSettings method)@\spxentry{generate\_fitting\_points()}\spxextra{hotspots.hs\_docking.DockerSettings method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_docking_api:hotspots.hs_docking.DockerSettings.generate_fitting_points}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate\_fitting\_points}}}{\emph{\DUrole{n}{hr}}, \emph{\DUrole{n}{volume}\DUrole{o}{=}\DUrole{default_value}{400}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{17}}, \emph{\DUrole{n}{mode}\DUrole{o}{=}\DUrole{default_value}{\textquotesingle{}threshold\textquotesingle{}}}}{}
uses the Fragment Hotspot Maps to generate GOLD fitting points.

GOLD fitting points are used to help place the molecules into the protein cavity. Pre\sphinxhyphen{}generating these fitting
points using the Fragment Hotspot Maps helps to biast results towards making Hotspot interactions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{hr}} (\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.result.Result}}) \textendash{} a Fragment Hotspot Maps result

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{volume}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} volume of the occupied by fitting points in Angstroms \textasciicircum{} 3

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{threshold}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} points above this value will be included in the fitting points

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mode}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} ‘threshold’\sphinxhyphen{} assigns fitting points based on a score cutoff or ‘bcv’\sphinxhyphen{} assigns fitting points from best continuous volume analysis (recommended)

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Hotspot Utilities API}
\label{\detokenize{hs_utilities_api:module-hotspots.hs_utilities}}\label{\detokenize{hs_utilities_api:hotspot-utilities-api}}\label{\detokenize{hs_utilities_api::doc}}\index{module@\spxentry{module}!hotspots.hs\_utilities@\spxentry{hotspots.hs\_utilities}}\index{hotspots.hs\_utilities@\spxentry{hotspots.hs\_utilities}!module@\spxentry{module}}
The \sphinxcode{\sphinxupquote{hotspots.utilities}} module contains classes to for
general functionality.
\begin{description}
\item[{The main classes of the \sphinxcode{\sphinxupquote{hotspots.extraction}} module are:}] \leavevmode\begin{itemize}
\item {} 
{\hyperref[\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_utilities.Helper}}}}}

\item {} 
{\hyperref[\detokenize{hs_utilities_api:hotspots.hs_utilities.Figures}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{hotspots.hs\_utilities.Figures}}}}}

\end{itemize}

\end{description}
\index{Coordinates (class in hotspots.hs\_utilities)@\spxentry{Coordinates}\spxextra{class in hotspots.hs\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Coordinates}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.hs\_utilities.}}\sphinxbfcode{\sphinxupquote{Coordinates}}}{\emph{\DUrole{n}{x}}, \emph{\DUrole{n}{y}}, \emph{\DUrole{n}{z}}}{}~\index{x() (hotspots.hs\_utilities.Coordinates property)@\spxentry{x()}\spxextra{hotspots.hs\_utilities.Coordinates property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Coordinates.x}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{x}}}
Alias for field number 0

\end{fulllineitems}

\index{y() (hotspots.hs\_utilities.Coordinates property)@\spxentry{y()}\spxextra{hotspots.hs\_utilities.Coordinates property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Coordinates.y}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{y}}}
Alias for field number 1

\end{fulllineitems}

\index{z() (hotspots.hs\_utilities.Coordinates property)@\spxentry{z()}\spxextra{hotspots.hs\_utilities.Coordinates property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Coordinates.z}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{z}}}
Alias for field number 2

\end{fulllineitems}


\end{fulllineitems}

\index{Figures (class in hotspots.hs\_utilities)@\spxentry{Figures}\spxextra{class in hotspots.hs\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Figures}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.hs\_utilities.}}\sphinxbfcode{\sphinxupquote{Figures}}}
Class to handle the generation of hotspot related figures

TO DO: is there a better place for this to live?
\index{histogram() (hotspots.hs\_utilities.Figures static method)@\spxentry{histogram()}\spxextra{hotspots.hs\_utilities.Figures static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Figures.histogram}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{histogram}}}{\emph{\DUrole{n}{hr}}}{}
creates a histogram from the hotspot scores
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{hr}} ({\hyperref[\detokenize{result_api:hotspots.result.Results}]{\sphinxcrossref{\sphinxstyleliteralemphasis{\sphinxupquote{hotspots.result.Results}}}}}) \textendash{} a Fragment Hotspot Map result

\item[{Returns}] \leavevmode
data, plot

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Helper (class in hotspots.hs\_utilities)@\spxentry{Helper}\spxextra{class in hotspots.hs\_utilities}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper}}\pysigline{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{hotspots.hs\_utilities.}}\sphinxbfcode{\sphinxupquote{Helper}}}
A class to handle miscellaneous functionality
\index{cavity\_centroid() (hotspots.hs\_utilities.Helper static method)@\spxentry{cavity\_centroid()}\spxextra{hotspots.hs\_utilities.Helper static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper.cavity_centroid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{cavity\_centroid}}}{\emph{\DUrole{n}{obj}}}{}
returns the centre of a cavity
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{obj}} \textendash{} can be a \sphinxtitleref{ccdc.cavity.Cavity} or

\item[{Returns}] \leavevmode
Coordinate

\end{description}\end{quote}

\end{fulllineitems}

\index{cavity\_from\_protein() (hotspots.hs\_utilities.Helper static method)@\spxentry{cavity\_from\_protein()}\spxextra{hotspots.hs\_utilities.Helper static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper.cavity_from_protein}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{cavity\_from\_protein}}}{\emph{\DUrole{n}{prot}}}{}
currently the Protein API doesn’t support the generation of cavities directly from the Protein instance
this method handles the tedious writing / reading
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{prot}} (\sphinxstyleliteralemphasis{\sphinxupquote{ccdc.protein.Protein}}) \textendash{} protein

\item[{Returns}] \leavevmode
\sphinxtitleref{ccdc.cavity.Cavity}

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_atom\_type() (hotspots.hs\_utilities.Helper static method)@\spxentry{get\_atom\_type()}\spxextra{hotspots.hs\_utilities.Helper static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper.get_atom_type}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_atom\_type}}}{\emph{\DUrole{n}{atom}}}{}
return the atom classification
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{atom}} \textendash{} 

\item[{Returns}] \leavevmode


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_distance() (hotspots.hs\_utilities.Helper static method)@\spxentry{get\_distance()}\spxextra{hotspots.hs\_utilities.Helper static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper.get_distance}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_distance}}}{\emph{\DUrole{n}{coords1}}, \emph{\DUrole{n}{coords2}}}{}
given two coordinates, calculates the distance
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords1}} (\sphinxstyleliteralemphasis{\sphinxupquote{tup}}) \textendash{} float(x), float(y), float(z), coordinates of point 1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{coords2}} (\sphinxstyleliteralemphasis{\sphinxupquote{tup}}) \textendash{} float(x), float(y), float(z), coordinates of point 2

\end{itemize}

\item[{Returns}] \leavevmode
float, distance

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_label() (hotspots.hs\_utilities.Helper static method)@\spxentry{get\_label()}\spxextra{hotspots.hs\_utilities.Helper static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper.get_label}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_label}}}{\emph{\DUrole{n}{input}}, \emph{\DUrole{n}{threshold}\DUrole{o}{=}\DUrole{default_value}{None}}}{}
creates a value labels from an input grid dictionary
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{input}} (\sphinxstyleliteralemphasis{\sphinxupquote{dic}}) \textendash{} key = “probe identifier” and value = \sphinxtitleref{ccdc.utilities.Grid}

\item[{Return ccdc.molecule.Molecule\sphinxtitleref{ccdc.molecule.Molecule}}] \leavevmode
pseduomolecule which contains score labels

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_lines\_from\_file() (hotspots.hs\_utilities.Helper static method)@\spxentry{get\_lines\_from\_file()}\spxextra{hotspots.hs\_utilities.Helper static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper.get_lines_from_file}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_lines\_from\_file}}}{\emph{\DUrole{n}{fname}}}{}
gets lines from text file, used in Ghecom calculation
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
list, list of str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_out\_dir() (hotspots.hs\_utilities.Helper static method)@\spxentry{get\_out\_dir()}\spxextra{hotspots.hs\_utilities.Helper static method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{hs_utilities_api:hotspots.hs_utilities.Helper.get_out_dir}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{static }}\sphinxbfcode{\sphinxupquote{get\_out\_dir}}}{\emph{\DUrole{n}{path}}}{}
checks if directory exists, if not, it create the directory
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{path}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}) \textendash{} path to directory

\item[{Return str}] \leavevmode
path to output directory

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{h}
\item\relax\sphinxstyleindexentry{hotspots.calculation}\sphinxstyleindexpageref{calculation_api:\detokenize{module-hotspots.calculation}}
\item\relax\sphinxstyleindexentry{hotspots.hs\_docking}\sphinxstyleindexpageref{hs_docking_api:\detokenize{module-hotspots.hs_docking}}
\item\relax\sphinxstyleindexentry{hotspots.hs\_io}\sphinxstyleindexpageref{hs_io_api:\detokenize{module-hotspots.hs_io}}
\item\relax\sphinxstyleindexentry{hotspots.hs\_pharmacophore}\sphinxstyleindexpageref{hs_pharmacophore_api:\detokenize{module-hotspots.hs_pharmacophore}}
\item\relax\sphinxstyleindexentry{hotspots.hs\_utilities}\sphinxstyleindexpageref{hs_utilities_api:\detokenize{module-hotspots.hs_utilities}}
\item\relax\sphinxstyleindexentry{hotspots.result}\sphinxstyleindexpageref{result_api:\detokenize{module-hotspots.result}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}