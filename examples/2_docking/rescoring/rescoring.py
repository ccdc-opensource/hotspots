"""
The rescoring script is a “cookbook” example of how the Fragment hotspot maps can be used to rescore ligands.
There are many different ways that this can be done. For best results the rescoring scheme should be tailored
to the problem in hand.

There are two scoring schemes provided:

    1) simple_score() : this scores each atom based upon it's interaction type, within a tolerance radius.
    The molecule score is the mean of the atom scores

    2) example_score(): this scores each interaction type separately. For each interaction type, a score is
    generated by evaluating the degree of matching between the molecule and hotspot maps and the degree of
    'non-matching'. Clash scores are also generated and are counts of the number of grid point within a VDW
    radius of a protein atom.

All the data generated is output in an sdf file.

"""
from collections import OrderedDict

import numpy as np
from ccdc.io import MoleculeReader

from hotspots.grid_extension import Grid
from hotspots.hs_io import HotspotReader
from hotspots.hs_utilities import Helper


def _output_sdf(mols, outname):
    """
    A work around.
    CSD python API does not output data point when writing to SDF. Do it manually'.

    :param ranked: list of ranked molecules
    :type ranked: `collections.OrderDict`
    :param outname: output filename
    :type outname: str
    """
    with open(outname, "w") as w:
        for mol in mols:
            mol_str = mol.to_string("sdf")
            insert = f"\nM  END"
            for k, v in mol.data.items():
                insert += f"\n>  <{k}>\n{v}\n"
            head_tail = mol_str.split("\nM  END")
            head_tail.insert(1, insert)
            out = "".join(head_tail)
            w.write(out)


def _molecule_as_grid(mol, g=None):
    """
    Produces a grid representation of a molecule split by interaction type

    :param mol: takes any ccdc molecule
    :type mol: `ccdc.molecule.Molecule`
    :param g: a blank grid
    :type g: `hotspots.grid_extension.Grid`

    :return: a dictionary of grids by interaction type
    :rtype: dict
    """
    if not g:
        g = Grid.initalise_grid(coords=[a.coordinates for a in mol.atoms],
                                padding=3)

    grid_dict = {"donor": g.copy(),
                 "acceptor": g.copy(),
                 "apolar": g.copy()}

    for p, g in grid_dict.items():
        atms = [a for a in mol.atoms if Helper.get_atom_type(a) == p]
        for atm in atms:
            g.set_sphere(point=atm.coordinates,
                         radius=atm.vdw_radius,
                         value=1,
                         scaling='None')

    return grid_dict


def _shrink(small, big, reverse_padding=1):
    """
    shrink a big grid to the dimension of a small grid

    :param small: a grid with desired dimensions
    :type small: `hotspots.grid_extension.Grid`
    :param big: the grid to be shrunk
    :type big: `hotspots.grid_extension.Grid`
    :param reverse_padding: amount of erosion within the small grid boundaries (ensures fit)
    :type reverse_padding: int

    :return: shrunk grid
    :rtype: `hotspots.grid_extension.Grid`
    """

    origin, far_left = small.bounding_box
    o = big.point_to_indices(origin)
    o = [i + reverse_padding for i in o]

    f = big.point_to_indices(far_left)
    f = [i - reverse_padding for i in f]

    h = big.sub_grid(o + f)
    return small.common_boundaries(h)


def example_score(sub_grids, mol, grid):
    """
    An example of a more complex scoring scheme

    :param sub_grids: dictionary of hotspot grids
    :type sub_grids: dict
    :param mol: takes any ccdc molecule
    :type mol: `ccdc.molecule.Molecule`
    :param grid: grid with the desired output dimensions
    :type grid: `ccdc.utilities.Grid`
    :return:
    """
    mol_grids = _molecule_as_grid(mol, grid)

    # take into account atoms which 'clash' / 'don't match' with the hotspot maps
    bad_interaction_dict = {'apolar': ['acceptor','donor'],
                            'donor': ['acceptor', 'apolar'],
                            'acceptor': ['donor', 'apolar']}

    # sub_grid dimension must be the same a mol_grid
    assert sub_grids["apolar"].bounding_box[0] == mol_grids["apolar"].bounding_box[0] and \
           sub_grids["apolar"].bounding_box[1] == mol_grids["apolar"].bounding_box[1]

    scores_by_type = {}
    for probe in ['apolar', 'donor', 'acceptor']:
        # detemine clashes by atom type
        clash_g = (sub_grids[probe] < 0) * mol_grids[probe]
        clash_array = clash_g.get_array()
        scores_by_type[f"{probe}_clash"] = np.sum(clash_array)

        # overlap between the maps and the molecule X 2
        match_grid = (sub_grids[probe] > 0) * sub_grids[probe] * mol_grids[probe] * 2
        # match_grid.write(f"{probe}_match.grd")

        # non-match
        non_match_grids = [sub_grids[p] * (sub_grids[p] > 0) * mol_grids[probe] for p in sub_grids.keys()
                           if p in bad_interaction_dict[probe]]

        non_match_g = non_match_grids[0] + non_match_grids[1]
        # non_match_g.write(f"{probe}_nonmatch.grd")

        # the score is the difference between matches and non-matches
        score_g = match_grid - non_match_g
        # score_g.write(f"{probe}_overall.grd")

        score_array = score_g.get_array()
        non_zero = score_array[score_array != 0]

        if len(non_zero) > 0:
            score = np.mean(non_zero)
        else:
            # if the len of non-zeros is 0, there will be a runtime error
            score = 0

        scores_by_type[probe] = score

    return scores_by_type


def simple_score(hr, mol):
    """
    a simple method to score molecules

    :param hr: the hotspot
    :type hr: `hotspots.result.Result`
    :param mol: a ccdc molecule
    :type mol: `ccdc.molecule.Molecule`
    :return:
    """
    vals = [a.partial_charge for a in hr.score(mol).heavy_atoms]

    if len(vals) > 0:
        return np.mean(vals)
    else:
        return 0


def ranked_molecules(mols, sort_on):
    mol_by_score = {m: sum([m.data[k]for k in sort_on]) for m in mols }
    return list(OrderedDict(sorted(mol_by_score.items(), key=lambda item: item[1], reverse=True)).keys())


def main():
    # input files #############################
    mol_file = "data/gold_docking_poses.sdf"
    hotspot_files = "data/out.zip"
    output_file = "data/ranked.sdf"

    # option 1: rank based on apolar score
    # sort_on = ["apolar"]
    # option 2: rank based on donor and acceptor scores
    sort_on = ["donor", "acceptor"]
    # option 3:
    # sort_on = ["simple_score"]
    ###########################################

    # read hotspots and molecules
    mols = [m for m in MoleculeReader(mol_file)]   # so molecules can retain new attributes
    hr = HotspotReader(hotspot_files).read()

    for p, g in hr.super_grids.items():
        hr.super_grids[p] = g.max_value_of_neighbours()

    # create a grid which can contain all docking poses
    small_blank = Grid.initalise_grid(coords={atm.coordinates for mol in mols for atm in mol.heavy_atoms},
                                      padding=2)

    # set the protein to -1 to detect clashing
    protein_grid = hr.super_grids["apolar"].copy_and_clear()
    for atm in hr.protein.atoms:
        protein_grid.set_sphere(point=atm.coordinates,
                                radius=atm.vdw_radius * 0.9,
                                value=-1,
                                scaling='None')

    protein_grid = _shrink(small=small_blank, big=protein_grid)

    # shrink hotspot maps to save time
    sub_grids = {p: _shrink(small=small_blank, big=g) + protein_grid for p, g in hr.super_grids.items()}

    # score the mols
    for i, mol in enumerate(mols):
        scores = example_score(sub_grids, mol, small_blank)
        mol.data = scores

        simple = simple_score(hr, mol)
        mol.data.update({"simple_score": simple})

    ranked_mols = ranked_molecules(mols, sort_on)

    # output ranked mols in sdf format with data attached
    _output_sdf(ranked_mols, output_file)


if __name__ == "__main__":
    main()


